<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chinese Character Homepage</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‰∏≠</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            -webkit-overflow-scrolling: touch;
            overflow-y: scroll;
        }

        body {
            font-family: 'Microsoft YaHei', 'SimHei', 'Arial', sans-serif;
            background-image: url('res/guanyin.jpg');
            background-repeat: repeat;
            background-size: auto;
            background-color: #F5F5F3; /* Fallback color */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: auto; /* Allow horizontal scrolling when needed */
            overflow-y: auto; /* Allow vertical scrolling when content exceeds viewport */
            position: relative;
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #F5F5F3;
            opacity: 0.7; /* Adjust opacity to control shading intensity */
            z-index: -1;
            pointer-events: none;
        }

        /* HP Bar Styles */
        #hp-bar-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        #hp-bar-container.visible {
            display: flex;
        }

        #hp-bar-label {
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #hp-bar-background {
            width: 200px;
            height: 24px;
            background: rgba(50, 50, 50, 0.8);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }

        #hp-bar-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ef4444 0%, #f59e0b 50%, #10b981 100%);
            border-radius: 10px;
            transition: width 0.5s ease, background 0.3s ease;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }

        #hp-bar-text {
            font-size: 14px;
            font-weight: bold;
            color: #ffffff;
            min-width: 70px;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Timer Styles */
        #timer-container {
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        #timer-container.visible {
            display: flex;
        }

        #timer-icon {
            font-size: 20px;
        }

        #timer-text {
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
            min-width: 60px;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            font-family: 'Courier New', monospace;
        }

        /* Level Selection Screen */
        #level-selection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            padding: 20px 0; /* Add padding for better mobile spacing */
            touch-action: auto; /* Allow all touch interactions */
        }

        #level-selection-overlay.hidden {
            display: none;
        }
        
        /* Hide main content when level selection is shown */
        #level-selection-overlay:not(.hidden) ~ .top-bar,
        #level-selection-overlay:not(.hidden) ~ .top-bar-trigger,
        #level-selection-overlay:not(.hidden) ~ .main-content {
            display: none;
        }

        #level-selection-container {
            max-width: 1200px;
            width: 90%;
            padding: 40px 20px;
        }

        #level-selection-title {
            font-size: 60px;
            font-weight: bold;
            color: #ffffff;
            text-align: center;
            margin-bottom: 40px;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        #levels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            padding: 20px 0;
        }

        .level-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            touch-action: auto; /* Allow touch interactions */
        }

        .level-card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
        }

        .level-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        }

        .level-card.difficulty-easy::before {
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
        }

        .level-card.difficulty-medium::before {
            background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
        }

        .level-card.difficulty-hard::before {
            background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
        }

        .level-card.difficulty-expert::before {
            background: linear-gradient(90deg, #8b5cf6 0%, #a78bfa 100%);
        }

        .level-id {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 48px;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.05);
        }

        .level-name {
            font-size: 24px;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 10px;
            padding-right: 60px;
        }

        .level-description {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .level-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
        }

        .level-stat {
            text-align: center;
        }

        .level-stat-label {
            font-size: 11px;
            color: #6b7280;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .level-stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #1f2937;
            margin-top: 5px;
        }

        .level-difficulty {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .level-difficulty.easy {
            background: #d1fae5;
            color: #065f46;
        }

        .level-difficulty.medium {
            background: #fef3c7;
            color: #92400e;
        }

        .level-difficulty.hard {
            background: #fee2e2;
            color: #991b1b;
        }

        .level-difficulty.expert {
            background: #ede9fe;
            color: #5b21b6;
        }

        .level-start-btn {
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            touch-action: auto; /* Allow touch interactions */
        }

        .level-start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        /* Game Over Overlay */
        #game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: fadeIn 1s forwards;
        }

        #game-over-overlay.hidden {
            display: none;
        }

        #game-over-content {
            text-align: center;
            animation: slideIn 1s ease-out;
        }

        #game-over-title {
            font-size: 80px;
            font-weight: bold;
            color: #ef4444;
            margin: 0;
            text-shadow: 0 0 20px rgba(239, 68, 68, 0.8),
                         0 0 40px rgba(239, 68, 68, 0.6),
                         0 0 60px rgba(239, 68, 68, 0.4);
            animation: pulse 2s infinite;
        }

        #game-over-message {
            font-size: 24px;
            color: #ffffff;
            margin: 30px 0;
            opacity: 0;
            animation: fadeIn 1s 0.5s forwards;
        }

        #restart-btn {
            font-size: 24px;
            font-weight: bold;
            color: #ffffff;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border: 3px solid #ffffff;
            border-radius: 15px;
            padding: 15px 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            animation: fadeIn 1s 1s forwards, float 2s 2s infinite;
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.5);
        }

        #restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(239, 68, 68, 0.8);
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        /* Level Complete Overlay */
        #level-complete-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: fadeIn 1s forwards;
        }

        #level-complete-overlay.hidden {
            display: none;
        }

        #level-complete-content {
            text-align: center;
            animation: slideIn 1s ease-out;
            max-width: 450px;
            padding: 25px;
        }

        #level-complete-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 50%, #fbbf24 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0 0 15px 0;
            text-shadow: 0 0 40px rgba(251, 191, 36, 0.5);
            animation: pulse 2s infinite;
        }

        #level-complete-subtitle {
            font-size: 22px;
            font-weight: bold;
            color: #10b981;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px rgba(16, 185, 129, 0.6);
        }

        #level-complete-stats {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
            opacity: 0;
            animation: fadeIn 1s 0.5s forwards;
        }

        .level-complete-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .level-complete-stat-row:last-child {
            border-bottom: none;
        }

        .level-complete-stat-label {
            font-size: 16px;
            color: #9ca3af;
            font-weight: 500;
        }

        .level-complete-stat-value {
            font-size: 18px;
            color: #ffffff;
            font-weight: bold;
        }

        #level-complete-next-info {
            font-size: 18px;
            color: #fbbf24;
            margin: 20px 0 15px 0;
            font-weight: 600;
            opacity: 0;
            animation: fadeIn 1s 1s forwards;
        }

        #level-complete-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            opacity: 0;
            animation: fadeIn 1s 1.2s forwards;
        }

        .level-complete-btn {
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
            border: 2px solid #ffffff;
            border-radius: 12px;
            padding: 12px 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: float 2s 2.5s infinite;
        }

        #level-complete-next-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 4px 20px rgba(16, 185, 129, 0.5);
        }

        #level-complete-next-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(16, 185, 129, 0.8);
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        #level-complete-menu-btn {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.5);
        }

        #level-complete-menu-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(99, 102, 241, 0.8);
            background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%);
        }

        @keyframes sparkle {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.2);
            }
        }

        .top-bar {
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        
        .music-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            padding: 8px 15px;
            backdrop-filter: blur(10px);
            opacity: 0.7;
        }
        
        .music-toggle {
            width: 50px;
            height: 26px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .music-toggle.active {
            background: #4ade80;
        }
        
        .music-toggle::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        
        .music-toggle.active::after {
            transform: translateX(24px);
        }
        
        .voice-btn {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            padding: 0;
        }
        
        .voice-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }
        
        .voice-btn:active {
            transform: scale(0.95);
        }

        .main-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding: 20px;
            transition: margin-right 0.3s ease;
            min-width: fit-content; /* Allow content to determine minimum width */
        }
        
        .canvas-container-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 30px;
            position: relative;
        }
        
        .canvas-container-wrapper.horizontal-layout {
            flex-direction: row;
            align-items: center;
        }
        
        .canvas-container-wrapper.vertical-layout {
            flex-direction: column;
            align-items: center;
            overflow-x: auto; /* Allow horizontal scrolling if content is wider */
            overflow-y: visible; /* Let body handle vertical scrolling */
            width: 100%;
            padding-bottom: 20px; /* Add padding at bottom to ensure content is visible */
        }
        
        .container {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .debug-panel {
            display: none;
            width: 300px;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
            color: #ffffff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(10px);
        }

        .similarity-score {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 15px 30px;
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Microsoft YaHei', 'SimHei', 'Arial', sans-serif;
            backdrop-filter: blur(10px);
            z-index: 1000;
            text-align: center;
            min-width: 200px;
            transition: opacity 0.3s ease;
        }

        .similarity-score.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .similarity-score .label {
            font-size: 14px;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .similarity-score .value {
            font-size: 32px;
        }

        .similarity-score .value div {
            line-height: 1.4;
        }

        .similarity-score .good {
            color: #4ade80;
        }

        .similarity-score .medium {
            color: #fbbf24;
        }

        .similarity-score .poor {
            color: #f87171;
        }

        .debug-panel h3 {
            margin-bottom: 10px;
            font-size: 14px;
            color: #ffffff;
            text-align: center;
        }

        .debug-panel pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
        }

        .character-wrapper {
            position: relative;
            width: 80vmin;
            height: 80vmin;
            max-width: 800px;
            max-height: 800px;
            user-select: none; /* Prevent text selection */
        }

        #guide-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
            user-select: none; /* Prevent text selection */
        }

        #character-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            user-select: none; /* Prevent text selection */
        }


        #character-target {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        
        #character-target svg {
            width: 100% !important;
            height: 100% !important;
        }

        #next-stroke-btn {
            padding: 12px 28px;
            font-size: 15px;
            font-weight: 400;
            color: #9a9a9a;
            background: rgba(245, 245, 243, 0.6);
            border: 1px solid rgba(154, 154, 154, 0.2);
            border-radius: 20px;
            cursor: default;
            transition: all 0.3s ease;
            font-family: 'Microsoft YaHei', 'SimHei', 'Arial', sans-serif;
            letter-spacing: 0.5px;
            pointer-events: none; /* Make it non-clickable */
            user-select: none; /* Prevent text selection */
            opacity: 0.7;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            backdrop-filter: blur(8px);
            line-height: 1.4;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        #completed-characters-container {
            display: grid;
            grid-auto-flow: column;
            grid-template-rows: repeat(20, 36px); /* Default - will be overridden by JS */
            gap: 0;
            z-index: 1000;
            overflow: visible; /* Allow content to be visible */
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            direction: rtl; /* Makes new columns appear on the left */
            width: fit-content; /* Width based on content (number of columns) */
            height: fit-content; /* Height based on content (number of rows) */
        }
        
        /* Desktop-only positioning (overridden on mobile) */
        
        .canvas-container-wrapper.horizontal-layout #completed-characters-container {
            position: fixed;
            top: 120px; /* Moved down 100px from original 20px */
            right: 20px;
            width: auto; /* Allow width to grow based on content */
            height: auto; /* Allow height to grow based on content */
            max-height: calc(100vh - 240px); /* Maximum height constraint */
            overflow-y: auto; /* Scroll if content exceeds max height */
            /* Grid layout will be set dynamically by JavaScript based on character count */
        }
        
        .canvas-container-wrapper.vertical-layout #completed-characters-container {
            position: relative;
            margin-top: 30px;
            margin-bottom: 20px;
            height: auto; /* Grow naturally to show all content */
            min-height: 50px; /* Minimum height so it's visible even when empty */
            overflow-y: visible; /* Show all content vertically, let browser handle scrolling */
            width: fit-content; /* Grow to fit all content */
            min-width: 36px; /* At least one column width */
            display: grid; /* Ensure grid display is maintained */
            visibility: visible; /* Ensure it's visible */
        }

        .completed-character {
            width: 36px;
            height: 36px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .completed-character img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        /* Shining animation for completed character */
        @keyframes explosiveShine {
            0% {
                transform: scale(1);
                filter: brightness(1) drop-shadow(0 0 0px rgba(255, 255, 0, 0));
            }
            25% {
                transform: scale(1.15);
                filter: brightness(2) drop-shadow(0 0 40px rgba(255, 255, 0, 1)) drop-shadow(0 0 80px rgba(255, 200, 0, 0.8));
            }
            50% {
                transform: scale(1.1) rotate(5deg);
                filter: brightness(2.5) drop-shadow(0 0 60px rgba(255, 255, 255, 1)) drop-shadow(0 0 100px rgba(255, 200, 0, 1));
            }
            75% {
                transform: scale(1.2) rotate(-3deg);
                filter: brightness(2) drop-shadow(0 0 50px rgba(255, 255, 0, 0.9));
            }
            100% {
                transform: scale(1);
                filter: brightness(1) drop-shadow(0 0 0px rgba(255, 255, 0, 0));
            }
        }
        
        .character-wrapper.shining {
            animation: explosiveShine 0.8s ease-out;
            z-index: 9999;
        }
        
        /* Animated character thumbnail flying to container */
        .flying-thumbnail {
            position: fixed;
            z-index: 10000;
            pointer-events: none;
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* Desktop: hide trigger and show top bar */
        @media (min-width: 769px) {
            .top-bar-trigger {
                display: none;
            }
            
            .top-bar {
                top: 0 !important;
            }
        }
        
        @media (max-width: 768px) {
            .character-wrapper {
                width: 90vmin;
                height: 90vmin;
            }
            
            /* Mobile Layout: Reorganize top elements */
            body {
                padding-top: 0; /* Reset body padding */
            }
            
            .main-content {
                padding-top: 55px; /* Only HP bar visible (50px + 5px spacing) */
                min-height: 100vh;
            }
            
            /* First row: Level info + Sound + Music - Classic iPhone Style with auto-hide */
            .top-bar {
                position: fixed;
                top: -50px;
                left: 0;
                right: 0;
                width: 100%;
                z-index: 2000;
                background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
                border-bottom: 0.5px solid rgba(0, 0, 0, 0.1);
                padding: 8px 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
                height: 50px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
                backdrop-filter: blur(10px);
                transition: top 0.3s ease;
            }
            
            .top-bar.visible {
                top: 0;
            }
            
            /* Touch trigger area at top of screen */
            .top-bar-trigger {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                height: 30px;
                z-index: 2001;
                cursor: pointer;
                background: linear-gradient(180deg, rgba(0, 0, 0, 0.03) 0%, transparent 100%);
                pointer-events: auto;
            }
            
            /* Hide trigger when top bar is visible */
            body:has(.top-bar.visible) .top-bar-trigger {
                pointer-events: none;
                opacity: 0;
            }
            
            #next-stroke-btn {
                font-size: 14px;
                font-weight: 600;
                padding: 8px 12px;
                flex: 1;
                min-width: 0;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                color: #007aff !important;
                background: rgba(255, 255, 255, 0.9) !important;
                opacity: 1 !important;
                border: none !important;
                border-radius: 10px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8);
                transition: all 0.2s ease;
            }
            
            #next-stroke-btn:active {
                transform: scale(0.97);
                background: rgba(255, 255, 255, 0.7) !important;
            }
            
            #voice-btn {
                font-size: 20px;
                padding: 8px 10px;
                min-width: 42px;
                background: rgba(255, 255, 255, 0.9);
                border: none;
                border-radius: 10px;
                color: #007aff;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8);
                transition: all 0.2s ease;
            }
            
            #voice-btn:active {
                transform: scale(0.95);
                background: rgba(255, 255, 255, 0.7);
            }
            
            .music-control {
                gap: 6px;
                padding: 6px 10px;
                background: rgba(255, 255, 255, 0.9);
                border: none;
                border-radius: 10px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            }
            
            .music-icon {
                font-size: 16px;
                color: #007aff;
            }
            
            .music-toggle {
                width: 46px;
                height: 26px;
                background: #e5e5ea;
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
                border: none;
                transition: background 0.3s ease;
            }
            
            .music-toggle.active {
                background: #34c759;
                box-shadow: 0 2px 8px rgba(52, 199, 89, 0.3);
            }
            
            .music-toggle::after {
                width: 22px;
                height: 22px;
                background: #ffffff;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            }
            
            /* Second row: HP bar and Timer combined - Classic iPhone Style */
            #hp-bar-container {
                position: fixed;
                top: 0;
                left: 0;
                right: 32%;
                width: 68%;
                z-index: 1998;
                background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
                border-bottom: 0.5px solid rgba(0, 0, 0, 0.1);
                border-right: 0.5px solid rgba(0, 0, 0, 0.1);
                padding: 8px 12px;
                border-radius: 0;
                justify-content: center;
                height: 50px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
                backdrop-filter: blur(10px);
                transition: top 0.3s ease;
                pointer-events: none; /* Don't block trigger area */
            }
            
            #hp-bar-container * {
                pointer-events: auto; /* Re-enable for children */
            }
            
            .top-bar.visible ~ * #hp-bar-container,
            body:has(.top-bar.visible) #hp-bar-container {
                top: 50px;
            }
            
            #hp-bar-label {
                display: none; /* Hide HP label on mobile */
            }
            
            #hp-bar-background {
                flex: 1;
                max-width: 250px;
                height: 22px;
                background: #e5e5ea;
                border: none;
                border-radius: 11px;
                box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
            }
            
            #hp-bar-fill {
                /* Color set dynamically by JavaScript based on HP percentage */
                border-radius: 11px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
                transition: all 0.3s ease;
            }
            
            #hp-bar-text {
                display: none; /* Hide HP text value on mobile */
            }
            
            /* Timer - right portion of second row - Classic iPhone Style */
            #timer-container {
                position: fixed;
                top: 0;
                left: 68%;
                right: 0;
                width: 32%;
                z-index: 1998;
                background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
                border-bottom: 0.5px solid rgba(0, 0, 0, 0.1);
                border-left: 0.5px solid rgba(0, 0, 0, 0.1);
                padding: 8px 10px;
                border-radius: 0;
                justify-content: center;
                height: 50px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
                backdrop-filter: blur(10px);
                transition: top 0.3s ease;
                pointer-events: none; /* Don't block trigger area */
            }
            
            #timer-container * {
                pointer-events: auto; /* Re-enable for children */
            }
            
            body:has(.top-bar.visible) #timer-container {
                top: 50px;
            }
            
            #timer-icon {
                font-size: 18px;
                color: #8e8e93;
                text-shadow: none;
            }
            
            #timer-text {
                font-size: 16px;
                font-weight: 600;
                color: #1c1c1e;
                text-shadow: none;
                letter-spacing: 0.5px;
                font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;
            }
            
            /* Completed characters: 6 columns, flexible rows - Same as desktop */
            #completed-characters-container {
                /* Dynamic layout based on character count - set by JavaScript */
                grid-auto-flow: row;
                grid-template-columns: repeat(6, 36px); /* Default 6 columns - will be overridden by JS */
                grid-template-rows: auto;
                direction: ltr;
                width: auto;
                max-width: calc(6 * 36px + 20px); /* Default - will be overridden by JS */
                justify-content: center;
                margin: 20px auto;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 10px;
                padding: 10px;
                gap: 0;
                backdrop-filter: blur(10px);
            }
            
            .completed-character {
                width: 36px !important;
                height: 36px !important;
            }
            
            .completed-character img {
                border-radius: 4px;
            }
            
            .canvas-container-wrapper.vertical-layout #completed-characters-container {
                position: relative;
                margin: 20px auto;
                height: auto;
                min-height: 50px;
            }
            
            .canvas-container-wrapper.horizontal-layout #completed-characters-container {
                position: relative;
                top: auto;
                right: auto;
                bottom: auto;
                height: auto;
                margin: 20px auto;
            }
            
            /* Level selection mobile optimization */
            #level-selection-overlay {
                padding: 10px 0;
            }
            
            #level-selection-container {
                width: 95%;
                padding: 20px 10px;
            }
            
            #level-selection-title {
                font-size: 36px;
                margin-bottom: 20px;
            }
            
            #levels-grid {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 10px 0;
            }
            
            .level-card {
                padding: 20px;
            }
            
            .level-id {
                font-size: 32px;
            }
            
            .level-name {
                font-size: 20px;
            }
            
            .level-description {
                font-size: 13px;
            }
            
            .level-start-btn {
                font-size: 16px;
                padding: 12px 30px;
            }
        }

        @media (min-width: 1200px) {
            .character-wrapper {
                width: 70vmin;
                height: 70vmin;
            }
        }
    </style>
</head>
<body>
    <!-- HP Bar -->
    <div id="hp-bar-container">
        <div id="hp-bar-label">HP</div>
        <div id="hp-bar-background">
            <div id="hp-bar-fill"></div>
        </div>
        <div id="hp-bar-text">100 / 100</div>
    </div>
    
    <!-- Timer -->
    <div id="timer-container">
        <div id="timer-icon">‚è±Ô∏è</div>
        <div id="timer-text">00:00</div>
    </div>
    
    <!-- Level Selection Screen -->
    <div id="level-selection-overlay">
        <div id="level-selection-container">
            <h1 id="level-selection-title">Select Level</h1>
            <div id="levels-grid"></div>
        </div>
    </div>
    
    <!-- Game Over Overlay -->
    <div id="game-over-overlay" class="hidden">
        <div id="game-over-content">
            <h1 id="game-over-title">GAME OVER</h1>
            <p id="game-over-message">Your HP reached 0!</p>
            <button id="restart-btn">Restart</button>
        </div>
    </div>

    <div id="level-complete-overlay" class="hidden">
        <div id="level-complete-content">
            <h1 id="level-complete-title">üéâ LEVEL COMPLETE! üéâ</h1>
            <div id="level-complete-subtitle">Level 1: Basic Strokes</div>
            <div id="level-complete-stats">
                <div class="level-complete-stat-row">
                    <span class="level-complete-stat-label">‚è±Ô∏è Time</span>
                    <span class="level-complete-stat-value" id="level-complete-time">0:00</span>
                </div>
                <div class="level-complete-stat-row">
                    <span class="level-complete-stat-label">‚ù§Ô∏è HP Remaining</span>
                    <span class="level-complete-stat-value" id="level-complete-hp">100 / 100</span>
                </div>
                <div class="level-complete-stat-row">
                    <span class="level-complete-stat-label">‚úèÔ∏è Characters Completed</span>
                    <span class="level-complete-stat-value" id="level-complete-chars">6</span>
                </div>
            </div>
            <div id="level-complete-next-info">Ready for the next challenge?</div>
            <div id="level-complete-buttons">
                <button id="level-complete-next-btn" class="level-complete-btn">Next Level</button>
                <button id="level-complete-menu-btn" class="level-complete-btn">Level Select</button>
            </div>
        </div>
    </div>
    
    <div class="top-bar-trigger"></div>
    <div class="top-bar">
        <div id="next-stroke-btn">Next Stroke</div>
        <button id="voice-btn" class="voice-btn" title="Read current character">üîä</button>
        <div class="music-control">
            <div class="music-icon">üéµ</div>
            <div class="music-toggle" id="music-toggle"></div>
        </div>
    </div>
    
    <!-- Background music -->
    <audio id="background-music" loop>
        <source src="res/XJ0106.mp3" type="audio/mpeg">
    </audio>
    <!-- Completion sound effect -->
    <audio id="completion-sound" preload="auto">
        <!-- You can add your sound file here, e.g. <source src="res/completion.mp3" type="audio/mpeg"> -->
    </audio>
    <div id="similarity-score" class="similarity-score hidden">
        <div class="label">Similarity Score</div>
        <div class="value" id="similarity-value">0%</div>
    </div>
    <div class="main-content">
        <div class="canvas-container-wrapper horizontal-layout" id="canvas-container-wrapper">
            <div class="container">
                <div class="character-wrapper">
                    <canvas id="guide-canvas"></canvas>
                    <canvas id="character-canvas"></canvas>
                </div>
            </div>
            <div id="completed-characters-container"></div>
        </div>
        <div class="debug-panel">
            <h3>Character Data (Debug)</h3>
            <pre id="stroke-data-debug">Loading...</pre>
        </div>
    </div>

    <script>
        // Character learning mode - all characters from ToWriteText.txt
        let charactersToLearn = []; // Will be populated from all_strokes.json
        let currentCharacterIndex = 0;
        let character = '';
        let appInitialized = false; // Track if app has been initialized
        let isCompletingCharacter = false; // Prevent duplicate calls to onCharacterCompleted
        
        // LocalStorage key for saving progress
        const STORAGE_KEY = 'hanziWriter_currentCharacterIndex';
        
        // HP Bar system
        let maxHP = 100;
        let currentHP = 100;
        let isGameOver = false;
        
        // Level system
        let levelConfig = null;
        let currentLevel = null;
        
        // Timer system
        let timerStartTime = null;
        let timerInterval = null;
        let timerElapsedSeconds = 0;
        
        function startTimer() {
            timerStartTime = Date.now();
            timerElapsedSeconds = 0;
            updateTimerDisplay();
            
            // Update timer every second
            timerInterval = setInterval(() => {
                timerElapsedSeconds = Math.floor((Date.now() - timerStartTime) / 1000);
                updateTimerDisplay();
            }, 1000);
        }
        
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
        
        function resetTimer() {
            stopTimer();
            timerElapsedSeconds = 0;
            updateTimerDisplay();
        }
        
        function updateTimerDisplay() {
            const timerText = document.getElementById('timer-text');
            if (timerText) {
                const minutes = Math.floor(timerElapsedSeconds / 60);
                const seconds = timerElapsedSeconds % 60;
                timerText.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
        }
        
        // Level loading and selection functions
        async function loadLevelConfig() {
            try {
                // Add cache-busting parameter to force reload of latest data
                const response = await fetch(`level_config.json?v=${Date.now()}`);
                levelConfig = await response.json();
                console.log('Level config loaded:', levelConfig);
                return levelConfig;
            } catch (error) {
                console.error('Error loading level config:', error);
                return null;
            }
        }
        
        function displayLevelSelection() {
            const levelsGrid = document.getElementById('levels-grid');
            if (!levelsGrid || !levelConfig) return;
            
            levelsGrid.innerHTML = '';
            
            // Always show exactly 5 representative levels
            const totalLevels = levelConfig.levels.length;
            const spacing = Math.floor(totalLevels / 5);
            
            // Calculate 5 evenly-spaced representative indices
            const representativeIndices = [];
            for (let i = 0; i < 5; i++) {
                const idx = i * spacing;
                if (idx < totalLevels) {
                    representativeIndices.push(idx);
                }
            }
            
            console.log(`Showing 5 representative levels from ${totalLevels} total:`);
            console.log(`  Indices: ${representativeIndices.join(', ')} ‚Üí Levels: ${representativeIndices.map(i => i + 1).join(', ')}`);
            
            // Display the 5 representative levels
            representativeIndices.forEach((idx) => {
                const level = levelConfig.levels[idx];
                
                const card = document.createElement('div');
                card.className = `level-card difficulty-${level.difficulty}`;
                card.innerHTML = `
                    <div class="level-id">${level.id}</div>
                    <div class="level-name">${level.name}</div>
                    <div class="level-description">${level.description}</div>
                    <div class="level-stats">
                        <div class="level-stat">
                            <div class="level-stat-label">Characters</div>
                            <div class="level-stat-value">${level.numCharacters}</div>
                        </div>
                        <div class="level-stat">
                            <div class="level-stat-label">Level</div>
                            <div class="level-stat-value">#${idx + 1}</div>
                        </div>
                        <div class="level-stat">
                            <div class="level-stat-label">HP</div>
                            <div class="level-stat-value">${level.maxHP}</div>
                        </div>
                    </div>
                    <div class="level-difficulty ${level.difficulty}">${level.difficulty.toUpperCase()}</div>
                    <button class="level-start-btn" onclick="startLevel('${level.id}')">Start Level</button>
                `;
                levelsGrid.appendChild(card);
            });
        }
        
        async function startLevel(levelId) {
            const level = levelConfig.levels.find(l => l.id === levelId);
            if (!level) {
                console.error(`Level ${levelId} not found`);
                return;
            }
            
            currentLevel = level;
            
            // Set characters from level first
            charactersToLearn = level.characters.split('');
            
            // Load all_strokes.json if not already loaded
            if (Object.keys(allCharactersData).length === 0) {
                console.log('Loading all_strokes.json for level...');
                const loaded = await loadStrokesDataFromFile();
                if (!loaded) {
                    alert('Failed to load all_strokes.json. Please make sure the file exists.');
                    return;
                }
            }
            
            // Validate that all characters in this level are available
            const missingCharacters = [];
            for (const char of charactersToLearn) {
                if (!allCharactersData[char]) {
                    missingCharacters.push(char);
                }
            }
            
            if (missingCharacters.length > 0) {
                alert(`Cannot start level: The following characters are not found in all_strokes.json:\n${missingCharacters.join(', ')}\n\nAvailable characters: ${Object.keys(allCharactersData).join(', ')}`);
                console.error('Missing characters:', missingCharacters);
                console.log('Available characters in all_strokes.json:', Object.keys(allCharactersData));
                return;
            }
            
            // Hide level selection
            const levelSelection = document.getElementById('level-selection-overlay');
            if (levelSelection) {
                levelSelection.classList.add('hidden');
            }
            
            // Show HP bar and timer
            const hpBar = document.getElementById('hp-bar-container');
            const timer = document.getElementById('timer-container');
            if (hpBar) hpBar.classList.add('visible');
            if (timer) timer.classList.add('visible');
            
            currentCharacterIndex = 0;
            
            // Clear completed characters display
            const completedContainer = document.getElementById('completed-characters-container');
            if (completedContainer) {
                completedContainer.innerHTML = '';
            }
            
            // Set dynamic grid layout for mobile based on character count
            setCompletedCharactersLayout(level.numCharacters);
            
            // Set HP
            maxHP = level.maxHP;
            currentHP = maxHP;
            updateHPBar(maxHP);
            
            // Reset game state
            isGameOver = false;
            appInitialized = false; // Reset app initialization flag
            resetTimer();
            startTimer();
            
            console.log(`Starting Level ${level.id}: ${level.name}`);
            console.log(`Characters: ${level.characters}`);
            console.log(`HP: ${level.maxHP}`);
            
            // Initialize the game with the characters from this level only
            // Pass true to skip loading ToWriteText.txt
            await initializeApp(true);
        }
        
        function showLevelSelection() {
            const levelSelection = document.getElementById('level-selection-overlay');
            if (levelSelection) {
                levelSelection.classList.remove('hidden');
            }
            
            // Hide HP bar and timer
            const hpBar = document.getElementById('hp-bar-container');
            const timer = document.getElementById('timer-container');
            if (hpBar) hpBar.classList.remove('visible');
            if (timer) timer.classList.remove('visible');
        }
        
        function hideLevelSelection() {
            const levelSelection = document.getElementById('level-selection-overlay');
            if (levelSelection) {
                levelSelection.classList.add('hidden');
            }

            // Show HP bar and timer
            const hpBar = document.getElementById('hp-bar-container');
            const timer = document.getElementById('timer-container');
            if (hpBar) hpBar.classList.add('visible');
            if (timer) timer.classList.add('visible');
        }
        
        function setCompletedCharactersLayout(numCharacters) {
            const completedContainer = document.getElementById('completed-characters-container');
            if (!completedContainer) return;
            
            const isMobile = window.innerWidth < 768;
            let columns, rows;
            
            if (isMobile) {
                // MOBILE (VERTICAL) LAYOUT
                if (numCharacters <= 28) {
                    // For 28 or fewer characters: columns = numCharacters / 4, rows = 4
                    columns = Math.ceil(numCharacters / 4);
                    rows = 4;
                } else {
                    // For more than 28 characters: columns = 7, rows grow automatically
                    columns = 7;
                    rows = 'auto'; // Will grow as needed
                }
                
                // Apply mobile grid layout (row-based)
                completedContainer.style.gridAutoFlow = 'row';
                completedContainer.style.gridTemplateColumns = `repeat(${columns}, 36px)`;
                completedContainer.style.gridTemplateRows = ''; // Clear template rows
                completedContainer.style.gridAutoRows = '36px'; // Each row is 36px as added
                completedContainer.style.gridAutoColumns = ''; // Clear auto columns
                completedContainer.style.width = `calc(${columns} * 36px + 20px)`; // Set explicit width
                completedContainer.style.minWidth = `calc(${columns} * 36px + 20px)`;
                completedContainer.style.maxWidth = `calc(${columns} * 36px + 20px)`;
                completedContainer.style.height = 'auto'; // Allow height to grow
                completedContainer.style.minHeight = '56px'; // Min height (padding + 1 row)
                completedContainer.style.direction = 'ltr';
                
                console.log(`Mobile layout: ${numCharacters} chars ‚Üí ${columns} columns, rows grow dynamically`);
            } else {
                // DESKTOP (HORIZONTAL) LAYOUT
                if (numCharacters > 28) {
                    // For more than 28 characters: rows = 7, columns grow automatically
                    rows = 7;
                    columns = 'auto'; // Will grow as needed
                } else {
                    // For 28 or fewer characters: rows = numCharacters / 4, columns = 4
                    rows = Math.ceil(numCharacters / 4);
                    columns = 4;
                }
                
                // Apply desktop grid layout (column-based)
                completedContainer.style.gridAutoFlow = 'column';
                completedContainer.style.gridTemplateRows = rows === 'auto' ? 'repeat(7, 36px)' : `repeat(${rows}, 36px)`;
                completedContainer.style.gridTemplateColumns = ''; // CLEAR columns constraint
                completedContainer.style.gridAutoColumns = '36px'; // Each column is 36px as added
                completedContainer.style.gridAutoRows = ''; // Clear auto rows
                completedContainer.style.width = ''; // CLEAR fixed width
                completedContainer.style.minWidth = ''; // CLEAR min width
                completedContainer.style.maxWidth = ''; // CLEAR max width
                completedContainer.style.height = 'fit-content'; // Allow height to grow
                completedContainer.style.direction = 'rtl'; // New columns appear on the left
                
                console.log(`Desktop layout: ${numCharacters} chars ‚Üí ${rows} rows, columns grow dynamically`);
            }
        }
        
        function onLevelComplete() {
            stopTimer();
            
            const timeStr = `${Math.floor(timerElapsedSeconds / 60)}:${String(timerElapsedSeconds % 60).padStart(2, '0')}`;
            const hpLeft = Math.round(currentHP);
            
            // Find next level
            const currentLevelIndex = levelConfig.levels.findIndex(l => l.id === currentLevel.id);
            const nextLevel = currentLevelIndex >= 0 && currentLevelIndex < levelConfig.levels.length - 1 
                ? levelConfig.levels[currentLevelIndex + 1] 
                : null;
            
            // Update level complete overlay with current level info
            const overlay = document.getElementById('level-complete-overlay');
            const subtitle = document.getElementById('level-complete-subtitle');
            const timeDisplay = document.getElementById('level-complete-time');
            const hpDisplay = document.getElementById('level-complete-hp');
            const charsDisplay = document.getElementById('level-complete-chars');
            const nextInfo = document.getElementById('level-complete-next-info');
            const nextBtn = document.getElementById('level-complete-next-btn');
            
            if (subtitle) {
                subtitle.textContent = `Level ${currentLevel.id}: ${currentLevel.name}`;
            }
            
            if (timeDisplay) {
                timeDisplay.textContent = timeStr;
            }
            
            if (hpDisplay) {
                hpDisplay.textContent = `${hpLeft} / ${maxHP}`;
            }
            
            if (charsDisplay) {
                charsDisplay.textContent = currentLevel.numCharacters;
            }
            
            if (nextLevel) {
                if (nextInfo) {
                    nextInfo.textContent = `Ready for Level ${nextLevel.id}?`;
                }
                if (nextBtn) {
                    nextBtn.textContent = `Next: ${nextLevel.name}`;
                    nextBtn.style.display = 'block';
                }
            } else {
                // All levels completed
                if (nextInfo) {
                    nextInfo.textContent = 'üèÜ You completed ALL levels! üèÜ';
                }
                if (nextBtn) {
                    nextBtn.style.display = 'none';
                }
            }
            
            // Show overlay
            if (overlay) {
                overlay.classList.remove('hidden');
            }
        }
        
        function hideLevelComplete() {
            const overlay = document.getElementById('level-complete-overlay');
            if (overlay) {
                overlay.classList.add('hidden');
            }
        }
        
        function updateHPBar(newHP) {
            currentHP = Math.max(0, Math.min(maxHP, newHP));
            const hpPercentage = (currentHP / maxHP) * 100;
            
            const hpBarFill = document.getElementById('hp-bar-fill');
            const hpBarText = document.getElementById('hp-bar-text');
            
            if (hpBarFill && hpBarText) {
                hpBarFill.style.width = hpPercentage + '%';
                hpBarText.textContent = `${Math.round(currentHP)} / ${maxHP}`;
                
                // Change color based on HP percentage (using game color scheme)
                if (hpPercentage > 60) {
                    hpBarFill.style.background = 'linear-gradient(90deg, #3498db 0%, #2980b9 100%)'; // Blue shield/secondary bar
                } else if (hpPercentage > 30) {
                    hpBarFill.style.background = 'linear-gradient(90deg, #f1c40f 0%, #f39c12 100%)'; // Yellow warning
                } else {
                    hpBarFill.style.background = 'linear-gradient(90deg, #e74c3c 0%, #c0392b 100%)'; // Red HP bar (danger)
                }
            }
            
            // Check for game over
            if (currentHP <= 0) {
                showGameOver();
            }
        }
        
        function showGameOver() {
            isGameOver = true;
            stopTimer();
            const overlay = document.getElementById('game-over-overlay');
            if (overlay) {
                overlay.classList.remove('hidden');
            }
            console.log('GAME OVER! HP reached 0.');
        }
        
        function restartGame() {
            // Reset game over flag
            isGameOver = false;
            
            // Hide game over overlay
            const overlay = document.getElementById('game-over-overlay');
            if (overlay) {
                overlay.classList.add('hidden');
            }
            
            // Stop timer
            stopTimer();
            
            // Show level selection screen
            showLevelSelection();
        }
        
        function applyDamage(damage) {
            const newHP = currentHP - damage;
            updateHPBar(newHP);
            console.log(`HP: ${Math.round(currentHP)} / ${maxHP} (Damage: ${damage.toFixed(2)})`);
        }
        
        function resetHP() {
            updateHPBar(maxHP);
        }
        
        // Function to convert punishment to HP deduction
        function punishmentToHPDeduction(punishment) {
            if (punishment < 50) {
                return 0;
            } else {
                return punishment / 10;
            }
        }
        
        // Function to generate completion sound effect using Web Audio API
        function playCompletionSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Create a pleasant completion sound
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.log('Could not play completion sound:', e);
            }
        }
        
        // Load saved character index from localStorage
        function loadSavedCharacterIndex() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved !== null) {
                    const index = parseInt(saved, 10);
                    if (!isNaN(index) && index >= 0) {
                        console.log(`Loaded saved character index: ${index}`);
                        return index;
                    }
                }
            } catch (e) {
                console.warn('Could not load saved character index:', e);
            }
            return 0; // Default to first character
        }
        
        // Save current character index to localStorage
        function saveCharacterIndex(index) {
            try {
                localStorage.setItem(STORAGE_KEY, index.toString());
                console.log(`Saved character index: ${index}`);
            } catch (e) {
                console.warn('Could not save character index:', e);
            }
        }
        
        // Generate thumbnail for a character from stroke data
        function generateCharacterThumbnail(char, charData) {
            if (!charData || !charData.rawCharData || !charData.rawCharData.medians) {
                console.warn(`Cannot generate thumbnail for ${char}: missing stroke data`);
                return null;
            }
            
            // Create a temporary canvas to draw the character
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 420; // Use same size as main canvas
            tempCanvas.height = 420;
            const tempCtx = tempCanvas.getContext('2d');
            
            if (!tempCtx) return null;
            
            // Clear canvas
            tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Set drawing style
            tempCtx.strokeStyle = '#1C1C1C'; // Drawing color
            tempCtx.lineWidth = 15;
            tempCtx.lineCap = 'round';
            tempCtx.lineJoin = 'round';
            
            const medians = charData.rawCharData.medians;
            const canvasSize = tempCanvas.width;
            const dataWidth = 900;
            const dataHeight = 900;
            const strokeHalfWidth = 15 / 2;
            const padding = Math.max(strokeHalfWidth + 10, canvasSize * 0.1);
            const availableSize = canvasSize - (padding * 2);
            const scale = availableSize / Math.max(dataWidth, dataHeight);
            const offsetX = (canvasSize - (dataWidth * scale)) / 2;
            const offsetY = (canvasSize - (dataHeight * scale)) / 2;
            
            // Draw all strokes
            for (let i = 0; i < medians.length; i++) {
                const strokePoints = medians[i];
                if (!strokePoints || strokePoints.length === 0) continue;
                
                const canvasPoints = strokePoints.map(([x, y]) => {
                    return {
                        x: x * scale + offsetX,
                        y: (dataHeight - y) * scale + offsetY
                    };
                });
                
                tempCtx.beginPath();
                tempCtx.moveTo(canvasPoints[0].x, canvasPoints[0].y);
                for (let j = 1; j < canvasPoints.length; j++) {
                    tempCtx.lineTo(canvasPoints[j].x, canvasPoints[j].y);
                }
                tempCtx.stroke();
            }
            
            // Create thumbnail canvas (36x36)
            const thumbnailCanvas = document.createElement('canvas');
            thumbnailCanvas.width = 36;
            thumbnailCanvas.height = 36;
            const thumbnailCtx = thumbnailCanvas.getContext('2d');
            
            // Scale down to 36x36
            thumbnailCtx.drawImage(tempCanvas, 0, 0, 36, 36);
            
            // Convert to image data URL
            return thumbnailCanvas.toDataURL('image/png');
        }
        
        // Add thumbnail to container
        function addThumbnailToContainer(char, imageDataUrl) {
            const container = document.getElementById('completed-characters-container');
            if (!container) return;
            
            const img = document.createElement('img');
            img.src = imageDataUrl;
            img.alt = char;
            
            const completedDiv = document.createElement('div');
            completedDiv.className = 'completed-character';
            completedDiv.appendChild(img);
            
            container.appendChild(completedDiv);
            
            // Update container width based on number of columns
            updateContainerWidth();
        }
        
        // Update container width based on number of columns
        function updateContainerWidth() {
            const container = document.getElementById('completed-characters-container');
            if (!container) return;
            
            // Calculate number of columns (20 rows per column)
            const columnCount = Math.ceil(container.children.length / 20);
            const columnWidth = 36; // Each character is 36px wide
            const containerPadding = 20; // 10px left + 10px right
            const containerWidth = (columnCount * columnWidth) + containerPadding;
            
            container.style.width = `${containerWidth}px`;
            container.style.minWidth = `${containerWidth}px`;
            container.style.maxWidth = `${containerWidth}px`;
        }
        
        // Load previous characters' thumbnails when resuming
        async function loadPreviousCharactersThumbnails(startIndex) {
            if (startIndex <= 0) return; // No previous characters
            
            console.log(`Loading thumbnails for previous ${startIndex} characters...`);
            
            for (let i = 0; i < startIndex; i++) {
                const char = charactersToLearn[i];
                const charData = charactersStrokeDataList.find(c => c.character === char);
                
                if (charData) {
                    const thumbnail = generateCharacterThumbnail(char, charData);
                    if (thumbnail) {
                        addThumbnailToContainer(char, thumbnail);
                        console.log(`Loaded thumbnail for character ${i + 1}: ${char}`);
                    }
                } else {
                    console.warn(`Could not find data for character ${i + 1}: ${char}`);
                }
            }
            
            // Update container width based on columns
            const container = document.getElementById('completed-characters-container');
            if (container) {
                container.style.overflow = 'hidden';
                updateContainerWidth();
            }
        }
        
        // Background music control
        let backgroundMusic = null;
        let musicEnabled = false;
        
        function initMusicControl() {
            backgroundMusic = document.getElementById('background-music');
            const musicToggle = document.getElementById('music-toggle');
            
            if (!backgroundMusic || !musicToggle) {
                console.warn('Music elements not found');
                return;
            }
            
            // Stop any existing audio first (in case of page refresh)
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0; // Reset to beginning
            
            // Set initial state
            musicToggle.classList.add('active');
            musicEnabled = true;
            
            // Try to play music (may require user interaction)
            backgroundMusic.volume = 0.25; // Set volume to 25%
            backgroundMusic.loop = true; // Ensure looping is enabled
            
            // Toggle music on/off
            musicToggle.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event from bubbling to drag detection
                e.preventDefault();
                musicEnabled = !musicEnabled;
                
                if (musicEnabled) {
                    musicToggle.classList.add('active');
                    backgroundMusic.play().catch(err => {
                        console.log('Could not play music:', err);
                        // If autoplay fails, user will need to interact first
                    });
                } else {
                    musicToggle.classList.remove('active');
                    backgroundMusic.pause();
                }
            });
            
            // Try to start music after first user interaction
            document.addEventListener('click', function startMusic() {
                if (musicEnabled && backgroundMusic.paused) {
                    backgroundMusic.play().catch(err => {
                        console.log('Could not autoplay music:', err);
                    });
                }
                // Remove listener after first click
                document.removeEventListener('click', startMusic);
            }, { once: true });
            
            console.log('Music control initialized');
        }
        
        // Initialize voice button to read current character
        function initVoiceButton() {
            const voiceBtn = document.getElementById('voice-btn');
            
            if (!voiceBtn) {
                console.warn('Voice button not found');
                return;
            }
            
            voiceBtn.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event from bubbling to drag detection
                e.preventDefault();
                
                if (!character) {
                    console.log('No character to read');
                    return;
                }
                
                console.log(`Reading character: ${character}`);
                
                try {
                    // Cancel any ongoing speech
                    window.speechSynthesis.cancel();
                    
                    // Create new utterance
                    const utterance = new SpeechSynthesisUtterance(character);
                    utterance.lang = 'zh-CN'; // Chinese language
                    utterance.rate = 0.7; // Slower for clarity
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0;
                    
                    utterance.onstart = () => {
                        console.log(`Started speaking: ${character}`);
                        voiceBtn.style.background = 'rgba(74, 222, 128, 0.3)';
                    };
                    
                    utterance.onend = () => {
                        console.log(`Finished speaking: ${character}`);
                        voiceBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                    };
                    
                    utterance.onerror = (e) => {
                        console.log('Error speaking:', e);
                        voiceBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                    };
                    
                    window.speechSynthesis.speak(utterance);
                } catch (e) {
                    console.log('Could not speak character:', e);
                }
            });
            
            console.log('Voice button initialized');
        }
        
        
        // All characters stroke data loaded from all_strokes.json
        let allCharactersData = {};
        
        /**
         * Structured storage for stroke data - NEW STRUCTURE
         * 
         * CharacterStrokeData structure:
         * {
         *   character: string,           // The Chinese character
         *   unicode: number,             // Unicode code point
         *   unicodeHex: string,         // Unicode in hex format
         *   timestamp: string,          // ISO 8601 timestamp
         *   version: string,            // Data structure version
         *   source: string,             // Data source
         *   totalStrokes: number,       // Total number of strokes
         *   strokes: StrokeData[],      // Array of processed stroke data
         *   rawCharData: object         // Original unprocessed data
         * }
         * 
         * StrokeData structure:
         * {
         *   index: number,              // Stroke index (0-based)
         *   points: Point[],            // All points along stroke path
         *   pointCount: number,         // Number of points
         *   startPoint: Point,           // {x, y} - starting point
         *   endPoint: Point,            // {x, y} - ending point
         *   maxDistancePoint: Point,    // Point with max distance from start
         *   direction: {dx, dy},        // Direction vector
         *   angle: number,              // Angle in radians
         *   angleDegrees: number,       // Angle in degrees
         *   length: number,             // Total stroke length
         *   maxDistance: number,        // Max distance from start
         *   coordinateSystem: {         // Coordinate system info
         *     origin: string,           // "bottom-left" or "top-left"
         *     conversionHeight: number, // Reference height (e.g., 900)
         *     converted: boolean        // Whether converted to screen space
         *   },
         *   source: string,             // Data source: 'medians', 'path', 'points'
         *   processed: boolean,         // Whether processed
         *   switched: boolean,          // Whether start/end were switched
         *   rawData: any                // Original raw stroke data
         * }
         */
        
        // List to store first 5 characters in new structure
        let charactersStrokeDataList = [];
        
        // newHanziWriter class - encapsulates all drawing/writing functionality
        class newHanziWriter {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.guideCanvas = null;
                this.guideCtx = null;
                this.currentStrokeIndex = 0;
                this.totalStrokes = 0;
                this.isAnimating = false;
                this.drawnStrokes = [];
                this.guideDrawn = false; // Track if guide character has been drawn
                this.strokeData = {
                    character: null,
                    rawCharData: null,
                    strokes: [],
                    initialized: false
                };
            }
            
            initCanvas() {
                // Initialize main canvas for green strokes
                this.canvas = document.getElementById('character-canvas');
                if (!this.canvas) {
                    console.error('Canvas element not found');
                    return;
                }
                
                // Initialize guide canvas for background guide character
                this.guideCanvas = document.getElementById('guide-canvas');
                if (!this.guideCanvas) {
                    console.error('Guide canvas element not found');
                    return;
                }
                
                // Set canvas size to match container
                const wrapper = document.querySelector('.character-wrapper');
                const size = Math.min(wrapper.offsetWidth || 800, wrapper.offsetHeight || 800);
                this.canvas.width = size;
                this.canvas.height = size;
                this.guideCanvas.width = size;
                this.guideCanvas.height = size;
                
                this.ctx = this.canvas.getContext('2d');
                this.guideCtx = this.guideCanvas.getContext('2d');
                if (!this.ctx || !this.guideCtx) {
                    console.error('Could not get canvas context');
                    return;
                }
                
                // Clear main canvas (guide canvas stays as background)
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Set drawing style for main canvas
                this.ctx.strokeStyle = '#1C1C1C'; // Drawing color
                this.ctx.lineWidth = 25; // Larger strokes
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                console.log(`Canvas initialized: ${this.canvas.width}x${this.canvas.height}`);
                
                // Draw guide character on guide canvas if stroke data is available
                if (this.strokeData.rawCharData && this.strokeData.rawCharData.medians) {
                    this.drawGuideCharacter();
                    // Set currentStrokeIndex to zero after guide is prepared
                    this.currentStrokeIndex = 0;
                }
                
                const self = this;
                window.addEventListener('resize', () => {
                    const size = Math.min(wrapper.offsetWidth || 420, wrapper.offsetHeight || 420);
                    self.canvas.width = size;
                    self.canvas.height = size;
                    self.guideCanvas.width = size;
                    self.guideCanvas.height = size;
                    // Redraw guide on guide canvas
                    if (self.guideDrawn) {
                        self.drawGuideCharacter();
                    }
                    // Redraw all drawn strokes on main canvas
                    self.redrawAllStrokes();
                });
            }
            
            drawGuideCharacter() {
                if (!this.guideCtx || !this.strokeData.rawCharData || !this.strokeData.rawCharData.medians) return;
                
                const medians = this.strokeData.rawCharData.medians;
                if (medians.length === 0) return;
                
                // Ensure all stroke data is prepared when guide character is drawn
                // Check if strokes need to be processed (if lengths are missing)
                if (!this.strokeData.strokes || this.strokeData.strokes.length === 0 || 
                    this.strokeData.strokes.some(s => !s || s.length === null || s.length === undefined)) {
                    console.log('[drawGuideCharacter] Preparing all stroke data from rawCharData...');
                    this.prepareAllStrokeData();
                }
                
                // Clear guide canvas first
                this.guideCtx.clearRect(0, 0, this.guideCanvas.width, this.guideCanvas.height);
                
                // Get canvas dimensions and calculate scale/offset (same as drawStroke)
                const canvasSize = this.guideCanvas.width;
                const dataWidth = 900;
                const dataHeight = 900;
                const strokeHalfWidth = 25 / 2; // Use the actual stroke width for calculations
                const padding = Math.max(strokeHalfWidth + 10, canvasSize * 0.1);
                const availableSize = canvasSize - (padding * 2);
                const scale = availableSize / Math.max(dataWidth, dataHeight);
                const offsetX = (canvasSize - (dataWidth * scale)) / 2;
                const offsetY = (canvasSize - (dataHeight * scale)) / 2;
                
                // Draw all strokes in grey on guide canvas
                this.guideCtx.strokeStyle = '#9A9A9A'; // Guide character color
                this.guideCtx.lineWidth = 20; // Larger guide strokes
                this.guideCtx.lineCap = 'round';
                this.guideCtx.lineJoin = 'round';
                
                for (let i = 0; i < medians.length; i++) {
                    const strokePoints = medians[i];
                    if (!strokePoints || strokePoints.length === 0) continue;
                    
                    // Convert points to canvas coordinates
                    const canvasPoints = strokePoints.map(([x, y]) => {
                        return {
                            x: x * scale + offsetX,
                            y: (dataHeight - y) * scale + offsetY
                        };
                    });
                    
                    // Draw the stroke on guide canvas
                    this.guideCtx.beginPath();
                    this.guideCtx.moveTo(canvasPoints[0].x, canvasPoints[0].y);
                    for (let j = 1; j < canvasPoints.length; j++) {
                        this.guideCtx.lineTo(canvasPoints[j].x, canvasPoints[j].y);
                    }
                    this.guideCtx.stroke();
                }
                
                // Mark guide as drawn
                this.guideDrawn = true;
            }
            
            prepareAllStrokeData() {
                // Prepare all stroke data from rawCharData when guide character is drawn
                if (!this.strokeData.rawCharData || !this.strokeData.rawCharData.medians) {
                    return;
                }
                
                const medians = this.strokeData.rawCharData.medians;
                if (medians.length === 0) {
                    return;
                }
                
                // Rebuild strokes array with calculated lengths if missing
                if (!this.strokeData.strokes || this.strokeData.strokes.length !== medians.length) {
                    this.strokeData.strokes = [];
                }
                
                for (let i = 0; i < medians.length; i++) {
                    let stroke = this.strokeData.strokes[i];
                    
                    // If stroke doesn't exist or is missing length, calculate it
                    if (!stroke || stroke.length === null || stroke.length === undefined) {
                        const strokePoints = medians[i].map(([x, y]) => ({ x, y }));
                        
                        // Calculate stroke length from points
                        let length = 0;
                        for (let j = 1; j < strokePoints.length; j++) {
                            const dx = strokePoints[j].x - strokePoints[j - 1].x;
                            const dy = strokePoints[j].y - strokePoints[j - 1].y;
                            length += Math.sqrt(dx * dx + dy * dy);
                        }
                        
                        // Calculate angle data if needed (calculate manually since function is in different scope)
                        let angleData = null;
                        if (strokePoints.length >= 2) {
                            const startPoint = strokePoints[0];
                            let maxDistance = 0;
                            let endPoint = startPoint;
                            for (let j = 1; j < strokePoints.length; j++) {
                                const point = strokePoints[j];
                                const dx = point.x - startPoint.x;
                                const dy = point.y - startPoint.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > maxDistance) {
                                    maxDistance = dist;
                                    endPoint = point;
                                }
                            }
                            const dx = endPoint.x - startPoint.x;
                            const dy = endPoint.y - startPoint.y;
                            // Negate dy to match screen coordinates (Y increases downward on screen, but upward in character data)
                            angleData = {
                                startPoint: startPoint,
                                endPoint: endPoint,
                                direction: { dx, dy },
                                angle: Math.atan2(-dy, dx),
                                angleDegrees: Math.atan2(-dy, dx) * 180 / Math.PI,
                                length: length
                            };
                        }
                        
                        // Create or update stroke object
                        this.strokeData.strokes[i] = {
                            index: i,
                            rawData: medians[i],
                            points: strokePoints,
                            startPoint: angleData ? angleData.startPoint : (strokePoints[0] || null),
                            endPoint: angleData ? angleData.endPoint : (strokePoints[strokePoints.length - 1] || null),
                            direction: angleData ? angleData.direction : null,
                            angle: angleData ? angleData.angle : null,
                            angleDegrees: angleData ? angleData.angleDegrees : null,
                            length: length,
                            source: 'medians'
                        };
                    }
                }
                
                // Calculate distance between consecutive strokes (end point of stroke i to start point of stroke i+1)
                for (let i = 0; i < this.strokeData.strokes.length - 1; i++) {
                    const currentStroke = this.strokeData.strokes[i];
                    const nextStroke = this.strokeData.strokes[i + 1];
                    
                    if (currentStroke && currentStroke.endPoint && nextStroke && nextStroke.startPoint) {
                        const dx = nextStroke.startPoint.x - currentStroke.endPoint.x;
                        const dy = nextStroke.startPoint.y - currentStroke.endPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Store distance to next stroke in current stroke object
                        if (!currentStroke.distanceToNext) {
                            currentStroke.distanceToNext = distance;
                        } else {
                            // Update if already exists (in case of recalculation)
                            currentStroke.distanceToNext = distance;
                        }
                    }
                }
                
                // Last stroke has no next stroke, so distanceToNext is null/undefined
                
                this.strokeData.initialized = true;
            }
            
            redrawAllStrokes() {
                if (!this.ctx || !this.strokeData.rawCharData) return;
                
                // Only clear and redraw the main canvas (green strokes)
                // Guide canvas stays as background, no need to redraw
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw all completed strokes in green on main canvas
                this.ctx.strokeStyle = '#1C1C1C'; // Drawing color
                this.ctx.lineWidth = 15; // Thinner strokes
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                // Redraw all previously drawn strokes
                for (let i = 0; i < this.drawnStrokes.length; i++) {
                    this.drawStroke(this.drawnStrokes[i], false); // false = no animation
                }
            }
            
            drawStroke(strokeIndex, animate = true) {
                if (!this.ctx || !this.strokeData.rawCharData || !this.strokeData.rawCharData.medians) {
                    console.error('Cannot draw stroke: missing data');
                    return;
                }
                
                // Set isAnimating flag IMMEDIATELY before starting animation
                // This prevents other operations from interfering
                if (animate) {
                    this.isAnimating = true;
                }
                
                // Ensure stroke style is set to bright green
                this.ctx.strokeStyle = '#1C1C1C'; // Drawing color // Bright green
                this.ctx.lineWidth = 25; // Larger strokes
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                
                const medians = this.strokeData.rawCharData.medians;
                if (strokeIndex >= medians.length) {
                    console.error(`Stroke index ${strokeIndex} out of range`);
                    return;
                }
                
                const strokePoints = medians[strokeIndex];
                if (!strokePoints || strokePoints.length === 0) {
                    console.error(`No points for stroke ${strokeIndex}`);
                    return;
                }
                
                // Get canvas dimensions and calculate scale/offset
                const canvasSize = this.canvas.width;
                const dataWidth = 900; // Standard width for character data
                const dataHeight = 900; // Standard height for character data
                
                // Account for stroke width (half on each side) and padding
                const strokeHalfWidth = this.ctx.lineWidth / 2;
                const padding = Math.max(strokeHalfWidth + 10, canvasSize * 0.1); // At least 10px + stroke width
                const availableSize = canvasSize - (padding * 2);
                
                // Scale to fit within available space
                const scale = availableSize / Math.max(dataWidth, dataHeight);
                
                // Center the character
                const offsetX = (canvasSize - (dataWidth * scale)) / 2;
                const offsetY = (canvasSize - (dataHeight * scale)) / 2;
                
                // Convert points from data coordinates to canvas coordinates
                // Data uses bottom-left origin, canvas uses top-left origin
                const canvasPoints = strokePoints.map(([x, y]) => {
                    return {
                        x: x * scale + offsetX,
                        y: (dataHeight - y) * scale + offsetY // Flip y-axis
                    };
                });
                
                if (animate) {
                    // Animate stroke drawing
                    this.animateStrokeDrawing(canvasPoints);
                } else {
                    // Draw immediately
                    this.ctx.beginPath();
                    this.ctx.moveTo(canvasPoints[0].x, canvasPoints[0].y);
                    for (let i = 1; i < canvasPoints.length; i++) {
                        this.ctx.lineTo(canvasPoints[i].x, canvasPoints[i].y);
                    }
                    this.ctx.stroke();
                }
            }
            
            animateStrokeDrawing(points) {
                if (points.length === 0) {
                    this.isAnimating = false;
                    return;
                }
                
                this.isAnimating = true;
                let currentIndex = 0;
                // Calculate animation speed based on stroke length for consistent timing
                // Aim for ~300ms animation time regardless of stroke length
                const targetDuration = 300; // milliseconds
                const fps = 60; // frames per second
                const totalFrames = Math.ceil((targetDuration / 1000) * fps);
                const animationSpeed = Math.max(1, Math.ceil(points.length / totalFrames));
                
                const self = this;
                function animate() {
                    if (currentIndex >= points.length) {
                        self.isAnimating = false;
                        return;
                    }
                    
                    self.ctx.beginPath();
                    self.ctx.moveTo(points[0].x, points[0].y);
                    
                    const endIndex = Math.min(currentIndex + animationSpeed, points.length);
                    for (let i = 1; i < endIndex; i++) {
                        self.ctx.lineTo(points[i].x, points[i].y);
                    }
                    self.ctx.stroke();
                    
                    currentIndex = endIndex;
                    
                    if (currentIndex < points.length) {
                        requestAnimationFrame(animate);
                    } else {
                        self.isAnimating = false;
                    }
                }
                
                animate();
            }
        }
        
        // Create global instance
        const hanziWriter = new newHanziWriter();

            // Function to calculate stroke angle from points
            function calculateStrokeAngle(points) {
                if (!points || points.length < 2) {
                    return null;
                }
                
                const startPoint = points[0];
                
                // Find the point with maximum distance from start point
                let maxDistance = 0;
                let endPoint = startPoint;
                let endPointIndex = 0;
                
                for (let i = 1; i < points.length; i++) {
                    const point = points[i];
                    const dx = point.x - startPoint.x;
                    const dy = point.y - startPoint.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        endPoint = point;
                        endPointIndex = i;
                    }
                }
                
                
                // Use start and end points directly (no switching)
                const finalStartPoint = startPoint;
                const finalEndPoint = endPoint;
                
                // Convert stroke coordinates from bottom-left origin to screen coordinates (top-left origin)
                // Stroke coordinates: (0,0) at bottom-left, y increases upward
                // Screen coordinates: (0,0) at top-left, y increases downward
                // Use 900 as the reference height for conversion
                const conversionHeight = 900;
                
                // Convert stroke points to screen coordinates
                let startPointScreen = {
                    x: finalStartPoint.x,
                    y: conversionHeight - finalStartPoint.y  // Flip y-axis
                };
                
                let endPointScreen = {
                    x: finalEndPoint.x,
                    y: conversionHeight - finalEndPoint.y  // Flip y-axis
                };
                
                
                // Switch start and end points if endPoint x+y < startPoint x+y (after coordinate conversion)
                let finalStartPointScreen = startPointScreen;
                let finalEndPointScreen = endPointScreen;
                let switched = false;
                
                const startSum = startPointScreen.x + startPointScreen.y;
                const endSum = endPointScreen.x + endPointScreen.y;
                
                if (endSum < startSum) {
                    finalStartPointScreen = endPointScreen;
                    finalEndPointScreen = startPointScreen;
                    switched = true;
                }
                
                // Calculate direction vector using final converted coordinates (screen coordinate system)
                // Direction: from finalStartPointScreen to finalEndPointScreen
                const dx = finalEndPointScreen.x - finalStartPointScreen.x;
                const dy = finalEndPointScreen.y - finalStartPointScreen.y;
                
                // Calculate angle in radians using atan2
                // Angle is calculated from finalStartPointScreen towards finalEndPointScreen
                // Now using screen coordinates: (0,0) at top-left, y increases downward
                const angle = Math.atan2(dy, dx);
                const angleDegrees = angle * 180 / Math.PI;
                
                // Calculate approximate length
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    length += Math.sqrt(
                        Math.pow(curr.x - prev.x, 2) + 
                        Math.pow(curr.y - prev.y, 2)
                    );
                }
                
                return {
                    startPoint: finalStartPoint,
                    endPoint: finalEndPoint,
                    direction: { dx, dy },
                    angle: angle,
                    angleDegrees: angleDegrees,
                    length: length,
                    switched: switched  // Indicate if start/end were switched after coordinate conversion
                };
            }
            
            // Function to process and store stroke data
            function processStrokeData(charData) {
                if (!charData || !charData.strokes) {
                    console.log('No stroke data to process');
                    return;
                }
                
                hanziWriter.strokeData.rawCharData = charData;
                hanziWriter.strokeData.strokes = [];
                hanziWriter.totalStrokes = charData.strokes.length;
                
                // Helper function to parse SVG path
                function parseSVGPath(pathString) {
                    if (!pathString) return null;
                    const commands = pathString.match(/[MLml][\s]*([\d\.\-]+)[\s]*([\d\.\-]+)/g);
                    if (!commands || commands.length === 0) return null;
                    
                    const points = [];
                    for (let cmd of commands) {
                        const coords = cmd.match(/[\d\.\-]+/g);
                        if (coords && coords.length >= 2) {
                            points.push({ 
                                x: parseFloat(coords[0]), 
                                y: parseFloat(coords[1]) 
                            });
                        }
                    }
                    return points.length > 0 ? points : null;
                }
                
                // Process each stroke
                for (let i = 0; i < charData.strokes.length; i++) {
                    const rawStroke = charData.strokes[i];
                    const processedStroke = {
                        index: i,
                        rawData: rawStroke,  // Keep original data for reference
                        
                        // Extracted points
                        points: null,  // All points along the stroke
                        startPoint: null,  // {x, y}
                        endPoint: null,    // {x, y}
                        
                        // Calculated properties
                        direction: null,    // {dx, dy}
                        angle: null,        // angle in radians
                        angleDegrees: null, // angle in degrees
                        length: null,       // approximate stroke length
                        
                        // Metadata
                        source: null  // Which property was used: 'medians', 'path', 'points'
                    };
                    
                    // Try to extract points from different sources
                    let extractedPoints = null;
                    
                    // Try medians first (common in HanziWriter)
                    if (rawStroke.medians && rawStroke.medians.length > 0) {
                        extractedPoints = rawStroke.medians.map(m => ({ x: m[0], y: m[1] }));
                        processedStroke.source = 'medians';
                    } 
                    // Try path (SVG path data)
                    else if (rawStroke.path) {
                        extractedPoints = parseSVGPath(rawStroke.path);
                        processedStroke.source = 'path';
                    }
                    // Try points array
                    else if (rawStroke.points && rawStroke.points.length > 0) {
                        extractedPoints = rawStroke.points.map(p => {
                            if (Array.isArray(p)) {
                                return { x: p[0], y: p[1] };
                            }
                            return p;
                        });
                        processedStroke.source = 'points';
                    }
                    
                    // If we got points, process them
                    if (extractedPoints && extractedPoints.length > 0) {
                        processedStroke.points = extractedPoints;
                        
                        // Calculate stroke angle using the separate function
                        const angleData = calculateStrokeAngle(extractedPoints);
                        if (angleData) {
                            processedStroke.startPoint = angleData.startPoint;
                            processedStroke.endPoint = angleData.endPoint;
                            processedStroke.direction = angleData.direction;
                            processedStroke.angle = angleData.angle;
                            processedStroke.angleDegrees = angleData.angleDegrees;
                            processedStroke.length = angleData.length;
                        }
                    }
                    
                    hanziWriter.strokeData.strokes.push(processedStroke);
                }
                
                hanziWriter.strokeData.initialized = true;
                console.log('Stroke data processed:', hanziWriter.strokeData);
                console.log(`Processed ${hanziWriter.strokeData.strokes.length} strokes`);
            }
            
            // Fallback function for browsers without File System Access API
            function downloadFile(jsonString, fileName = null) {
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = fileName || `stroke_data_${character}_${Date.now()}.json`;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up
                URL.revokeObjectURL(url);
                
                console.log(`File downloaded as: ${link.download}`);
            }
            

            // Button click handlers
            function attachButtonHandler() {
                const btn = document.getElementById('next-stroke-btn');
                if (btn) {
                    // Remove any existing handlers
                    btn.onclick = null;
                    btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('=== BUTTON CLICKED ===');
                        drawNextStroke();
                    });
                    console.log('‚úì Button click handler attached');
                    return true;
                } else {
                    console.error('‚úó Button not found!');
                    return false;
                }
            }
            
            // Try to attach immediately
            if (!attachButtonHandler()) {
                // If button not found, try again after DOM is ready
                setTimeout(() => {
                    if (attachButtonHandler()) {
                        console.log('Button handler attached on retry');
                    }
                }, 100);
            }
            
        // Load all characters into new structure (in order from ToWriteText.txt)
        function loadAllCharactersIntoStructure() {
            // Clear existing data to prevent duplicates
            if (charactersStrokeDataList.length > 0) {
                console.log('Clearing existing structure data...');
                charactersStrokeDataList = [];
            }
            
            // charactersToLearn is already populated from ToWriteText.txt in order
            console.log(`Loading ${charactersToLearn.length} characters into new structure (in order from ToWriteText.txt)...`);
            
            for (let i = 0; i < charactersToLearn.length; i++) {
                const char = charactersToLearn[i];
                console.log(`Processing character ${i + 1}/${charactersToLearn.length}: ${char}`);
                
                if (!allCharactersData[char]) {
                    console.warn(`Character ${char} not found in allCharactersData`);
                    continue;
                }
                
                const charData = allCharactersData[char];
                
                // Calculate totalStrokes from available sources
                let calculatedTotalStrokes = 0;
                if (charData.totalStrokes && charData.totalStrokes > 0) {
                    calculatedTotalStrokes = charData.totalStrokes;
                } else if (charData.strokes && charData.strokes.length > 0) {
                    calculatedTotalStrokes = charData.strokes.length;
                } else if (charData.rawCharData && charData.rawCharData.strokes && charData.rawCharData.strokes.length > 0) {
                    calculatedTotalStrokes = charData.rawCharData.strokes.length;
                }
                
                // Create structured data entry
                const structuredData = {
                    character: char,
                    unicode: char.charCodeAt(0),
                    unicodeHex: char.charCodeAt(0).toString(16).toUpperCase().padStart(4, '0'),
                    timestamp: new Date().toISOString(),
                    version: '1.0',
                    source: 'all_strokes.json',
                    totalStrokes: calculatedTotalStrokes,
                    strokes: charData.strokes || [],
                    rawCharData: charData.rawCharData || null
                };
                
                // If strokes array is empty but we have rawCharData, we'll process it on demand
                if (structuredData.strokes.length === 0 && structuredData.rawCharData) {
                    console.log(`Character ${char} has no pre-processed strokes, will process from rawCharData when needed`);
                }
                
                if (calculatedTotalStrokes === 0) {
                    console.warn(`Character ${char} has totalStrokes = 0! This may cause issues.`);
                    console.log('charData:', charData);
                }
                
                charactersStrokeDataList.push(structuredData);
                console.log(`Added ${char} to structure list with ${structuredData.totalStrokes} strokes`);
            }
            
            console.log(`Loaded ${charactersStrokeDataList.length} characters into structure list`);
        }
        
        // Load ToWriteText.txt to get characters in order
        async function loadCharactersFromTextFile() {
            try {
                console.log('Fetching ToWriteText.txt...');
                const response = await fetch('ToWriteText.txt');
                if (response.ok) {
                    const text = await response.text();
                    // Extract all characters in order, including duplicates
                    charactersToLearn = Array.from(text).filter(char => {
                        // Keep Chinese characters and other non-whitespace characters
                        return char.trim().length > 0 && char !== '\n' && char !== '\r';
                    });
                    console.log(`Loaded ${charactersToLearn.length} characters from ToWriteText.txt in order`);
                    console.log('First 20 characters:', charactersToLearn.slice(0, 20).join(''));
                    return true;
                } else {
                    console.error(`Failed to load ToWriteText.txt: ${response.status}`);
                    return false;
                }
            } catch (error) {
                console.error('Error loading ToWriteText.txt:', error);
                return false;
            }
        }
        
        // Load all_strokes.json first, then load all characters into new structure
        async function initializeApp(skipTextFile = false) {
            // If skipTextFile is true, we're coming from level selection and charactersToLearn is already set
            if (!skipTextFile) {
                console.log('Initializing app - loading ToWriteText.txt...');
                const textLoaded = await loadCharactersFromTextFile();
                if (!textLoaded) {
                    alert('Failed to load ToWriteText.txt. Please make sure the file exists in the same directory.');
                    return;
                }
            } else {
                console.log('Initializing app - using characters from selected level...');
                console.log('Characters to learn:', charactersToLearn.join(''));
            }
            
            console.log('Initializing app - loading all_strokes.json...');
            const loaded = await loadStrokesDataFromFile();
            if (!loaded) {
                alert('Failed to load all_strokes.json. Please make sure the file exists in the same directory.');
                return;
            }
            
            // Load all characters into new structure (in order from ToWriteText.txt or level)
            console.log('Loading all characters into new structure...');
            loadAllCharactersIntoStructure();
            
            // Log the loaded structure
            console.log(`Loaded ${charactersStrokeDataList.length} characters into new structure`);
            
            // Set initial character
            if (charactersToLearn.length > 0) {
                // When starting from level selection, always start from first character (index 0)
                const startIndex = skipTextFile ? 0 : loadSavedCharacterIndex();
                // Make sure the saved index is valid
                const validIndex = Math.min(startIndex, charactersToLearn.length - 1);
                
                // Load thumbnails for previous characters if resuming (skip if from level selection)
                if (!skipTextFile && validIndex > 0) {
                    await loadPreviousCharactersThumbnails(validIndex);
                }
                
                // Update main canvas position after loading thumbnails
                setTimeout(() => {
                    updateMainCanvasPosition();
                }, 100);
                
                // Also update on window resize
                window.addEventListener('resize', updateMainCanvasPosition);
                
                character = charactersToLearn[validIndex];
                // Start processing from saved character (or first if none saved)
                processSingleCharacter(validIndex);
            } else {
                alert('No characters available');
            }
        }
        
        // Stop audio when page is about to unload (refresh/close)
        window.addEventListener('beforeunload', function() {
            if (backgroundMusic) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
            }
        });
        
        // Initialize top bar auto-hide functionality for mobile
        function initTopBarAutoHide() {
            // Only enable on mobile (< 768px)
            if (window.innerWidth >= 768) return;
            
            const topBar = document.querySelector('.top-bar');
            const trigger = document.querySelector('.top-bar-trigger');
            let hideTimeout;
            
            // Show top bar
            function showTopBar() {
                topBar.classList.add('visible');
                
                // Auto-hide after 3 seconds
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    topBar.classList.remove('visible');
                }, 3000);
            }
            
            // Hide top bar immediately
            function hideTopBar() {
                clearTimeout(hideTimeout);
                topBar.classList.remove('visible');
            }
            
            // Show on trigger area touch/hover
            if (trigger) {
                trigger.addEventListener('touchstart', showTopBar);
                trigger.addEventListener('mouseenter', showTopBar);
            }
            
            // Show on top bar touch/hover - restart hide timer
            if (topBar) {
                topBar.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    showTopBar();
                });
                topBar.addEventListener('mouseenter', () => {
                    showTopBar();
                });
                topBar.addEventListener('mouseleave', () => {
                    // Start hide timer when mouse leaves
                    clearTimeout(hideTimeout);
                    hideTimeout = setTimeout(() => {
                        topBar.classList.remove('visible');
                    }, 3000);
                });
            }
            
            // Show initially for 3 seconds
            showTopBar();
        }
        
        // Initialize music control and app when page loads
        async function initPage() {
            // Stop any existing audio instances first
            if (backgroundMusic) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
            }
            // Initialize HP bar
            updateHPBar(maxHP);
            // Initialize restart button
            const restartBtn = document.getElementById('restart-btn');
            if (restartBtn) {
                restartBtn.addEventListener('click', restartGame);
            }
            
            // Initialize level complete buttons
            const levelCompleteNextBtn = document.getElementById('level-complete-next-btn');
            const levelCompleteMenuBtn = document.getElementById('level-complete-menu-btn');
            
            if (levelCompleteNextBtn) {
                levelCompleteNextBtn.addEventListener('click', () => {
                    hideLevelComplete();
                    // Find next level
                    const currentLevelIndex = levelConfig.levels.findIndex(l => l.id === currentLevel.id);
                    const nextLevel = currentLevelIndex >= 0 && currentLevelIndex < levelConfig.levels.length - 1 
                        ? levelConfig.levels[currentLevelIndex + 1] 
                        : null;
                    
                    if (nextLevel) {
                        startLevel(nextLevel.id);
                    } else {
                        showLevelSelection();
                    }
                });
            }
            
            if (levelCompleteMenuBtn) {
                levelCompleteMenuBtn.addEventListener('click', () => {
                    hideLevelComplete();
                    showLevelSelection();
                });
            }
            
            initMusicControl();
            initVoiceButton();
            initTopBarAutoHide();
            
            // Load level config and show level selection
            await loadLevelConfig();
            if (levelConfig) {
                displayLevelSelection();
                showLevelSelection();
            } else {
                alert('Failed to load level configuration. Please check level_config.json file.');
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPage);
        } else {
            initPage();
        }
        
        /**
         * Load character data from the new structure list
         */
        function loadCharacterDataFromStructure(char) {
            // Find character in the structured list
            const structuredCharData = charactersStrokeDataList.find(c => c.character === char);
            
            if (!structuredCharData) {
                console.error(`Character ${char} not found in charactersStrokeDataList`);
                console.error('Available characters in structure:', charactersStrokeDataList.map(c => c.character));
                return false;
            }
            
            console.log(`Loading character data from structure for: ${char}`);
            console.log(`Found structured data: ${structuredCharData.totalStrokes} strokes`);
            
            // Update strokeData with structured data
            hanziWriter.strokeData.character = structuredCharData.character;
            hanziWriter.strokeData.rawCharData = structuredCharData.rawCharData || null;
            
            console.log(`loadCharacterDataFromStructure: rawCharData for ${char}:`, hanziWriter.strokeData.rawCharData ? 'exists' : 'null');
            if (hanziWriter.strokeData.rawCharData) {
                console.log('‚úì rawCharData loaded successfully');
                console.log('rawCharData keys:', Object.keys(hanziWriter.strokeData.rawCharData));
                if (hanziWriter.strokeData.rawCharData.strokes) {
                    console.log(`‚úì rawCharData has ${hanziWriter.strokeData.rawCharData.strokes.length} strokes`);
                } else {
                    console.warn('‚úó rawCharData has no strokes array');
                }
            } else {
                console.error('‚úó rawCharData is null! This will cause problems.');
                console.log('structuredCharData.rawCharData:', structuredCharData.rawCharData ? 'exists' : 'null');
            }
            
            // Convert structured strokes to format expected by existing code
            hanziWriter.strokeData.strokes = structuredCharData.strokes.map(stroke => ({
                index: stroke.index,
                rawData: stroke.rawData || null,
                points: stroke.points || null,
                startPoint: stroke.startPoint,
                endPoint: stroke.endPoint,
                direction: stroke.direction,
                angle: stroke.angle,
                angleDegrees: stroke.angleDegrees,
                length: stroke.length,
                source: stroke.source,
                switched: stroke.switched || false
            }));
            
            hanziWriter.totalStrokes = structuredCharData.totalStrokes || (hanziWriter.strokeData.strokes ? hanziWriter.strokeData.strokes.length : 0);
            hanziWriter.strokeData.initialized = true;
            hanziWriter.currentStrokeIndex = 0;
            hanziWriter.drawnStrokes = [];
            
            console.log(`Successfully loaded ${char} from structure with ${hanziWriter.totalStrokes} strokes`);
            console.log(`totalStrokes set to: ${hanziWriter.totalStrokes}`);
            return true;
        }
        
        /**
         * Legacy function - kept for backward compatibility
         * Now uses the new structure list
         */
        function loadCharacterData(char) {
            // Try to load from new structure first
            if (charactersStrokeDataList.length > 0) {
                return loadCharacterDataFromStructure(char);
            }
            
            // Fallback to old method if structure list is empty
            console.log(`Loading character data for: ${char} (fallback to allCharactersData)`);
            console.log(`Available characters:`, Object.keys(allCharactersData));
            
            if (allCharactersData[char]) {
                const charData = allCharactersData[char];
                console.log(`Found data for ${char}:`, charData);
                hanziWriter.strokeData.rawCharData = charData.rawCharData || null;
                
                // If strokes array is empty but we have rawCharData, process it
                if (charData.strokes && charData.strokes.length > 0) {
                    console.log(`Using pre-processed strokes for ${char}:`, charData.strokes.length);
                    hanziWriter.strokeData.strokes = charData.strokes.map(stroke => ({
                        index: stroke.index,
                        rawData: stroke.rawData || null,
                        points: stroke.points || null,
                        startPoint: stroke.startPoint,
                        endPoint: stroke.endPoint,
                        direction: stroke.direction,
                        angle: stroke.angle,
                        angleDegrees: stroke.angleDegrees,
                        length: stroke.length,
                        source: stroke.source
                    }));
                    hanziWriter.totalStrokes = charData.totalStrokes || hanziWriter.strokeData.strokes.length;
                } else if (charData.rawCharData) {
                    // Process rawCharData to extract stroke information
                    console.log(`Processing rawCharData for character: ${char}`);
                    processStrokeData(charData.rawCharData);
                    hanziWriter.totalStrokes = hanziWriter.strokeData.strokes.length;
                    console.log(`Processed ${hanziWriter.totalStrokes} strokes for ${char}`);
                } else {
                    console.error(`No stroke data available for character: ${char}`);
                    console.error('charData:', charData);
                    return false;
                }
                
                hanziWriter.strokeData.initialized = true;
                hanziWriter.currentStrokeIndex = 0;
                hanziWriter.drawnStrokes = [];
                hanziWriter.isAnimating = false;
                console.log(`Successfully loaded ${char} with ${hanziWriter.totalStrokes} strokes`);
                return true;
            } else {
                console.error(`Character ${char} not found in allCharactersData`);
                console.error('Available characters:', Object.keys(allCharactersData));
                return false;
            }
        }
        
        async function loadStrokesDataFromFile() {
            // Load stroke data from all_strokes.json file
            try {
                console.log('Fetching all_strokes.json...');
                // Add cache-busting parameter to force reload of latest data
                const response = await fetch(`all_strokes.json?v=${Date.now()}`);
                console.log('Response status:', response.status, response.statusText);
                
                if (response.ok) {
                    const loadedData = await response.json();
                    console.log('Parsed JSON data. Keys:', Object.keys(loadedData));
                    
                    if (loadedData.characters && typeof loadedData.characters === 'object') {
                        allCharactersData = loadedData.characters;
                        const charCount = Object.keys(allCharactersData).length;
                        console.log(`Successfully loaded ${charCount} characters from all_strokes.json`);
                        console.log('First few characters:', Object.keys(allCharactersData).slice(0, 10));
                        return true;
                    } else {
                        console.error('Invalid data format. Expected "characters" object.');
                        console.error('Data structure:', Object.keys(loadedData));
                    }
                } else {
                    console.error(`HTTP error: ${response.status} ${response.statusText}`);
                }
                return false;
            } catch (error) {
                console.error('Error loading all_strokes.json:', error);
                console.error('Error details:', error.message, error.stack);
                return false;
            }
        }
        
        function processSingleCharacter(charIndex) {
            // Process a single character using the new structure list
            if (charIndex >= charactersToLearn.length) {
                // All characters completed
                console.log(`All ${charactersToLearn.length} characters completed!`);
                alert(`Congratulations! You have completed all ${charactersToLearn.length} characters!`);
                return;
            }
            
            character = charactersToLearn[charIndex];
            currentCharacterIndex = charIndex;
            // Save current character index to localStorage
            saveCharacterIndex(charIndex);
            
            console.log(`Processing character ${charIndex + 1}/${charactersToLearn.length}: ${character}`);
            
            // Check if structure list is loaded
            if (charactersStrokeDataList.length === 0) {
                console.error('charactersStrokeDataList is empty. Make sure initializeApp() has loaded the data.');
                alert('Character data not loaded. Please refresh the page.');
                return;
            }
            
            // Load stroke data from the new structure list
            console.log(`Loading stroke data for character: ${character}`);
            console.log(`charactersStrokeDataList has ${charactersStrokeDataList.length} characters`);
            
            if (!loadCharacterDataFromStructure(character)) {
                console.error(`Failed to load stroke data for: ${character} from structure list`);
                console.error('Available characters in structure:', charactersStrokeDataList.map(c => c.character));
                alert(`Stroke data not found for character: ${character}\n\nAvailable: ${charactersStrokeDataList.map(c => c.character).join(', ')}`);
                return;
            }
            
            console.log(`‚úì Character data loaded. strokeData.rawCharData:`, hanziWriter.strokeData.rawCharData ? 'exists' : 'null');
            if (hanziWriter.strokeData.rawCharData) {
                console.log(`‚úì rawCharData has ${hanziWriter.strokeData.rawCharData.strokes ? hanziWriter.strokeData.rawCharData.strokes.length : 0} strokes`);
            }
            
            console.log(`Loaded stroke data for ${character} from structure (${hanziWriter.totalStrokes} strokes)`);
            
            // Log structure information
            const structuredData = charactersStrokeDataList.find(c => c.character === character);
            if (structuredData) {
                console.log(`Character structure:`, {
                    character: structuredData.character,
                    unicodeHex: structuredData.unicodeHex,
                    totalStrokes: structuredData.totalStrokes,
                    version: structuredData.version,
                    source: structuredData.source
                });
            }
            
            // Reset stroke tracking (start at 0, no strokes drawn yet)
            hanziWriter.currentStrokeIndex = 0;
            hanziWriter.drawnStrokes = [];
            hanziWriter.isAnimating = false;
            hanziWriter.guideDrawn = false; // Reset guide flag for new character
            // DON'T reset totalStrokes - it should already be set from loadCharacterDataFromStructure
            console.log(`processSingleCharacter: totalStrokes = ${hanziWriter.totalStrokes}, character = ${character}`);
            
            // If totalStrokes is still 0, try to get it from structure
            if (hanziWriter.totalStrokes === 0) {
                const charData = charactersStrokeDataList.find(c => c.character === character);
                if (charData && charData.rawCharData && charData.rawCharData.medians) {
                    hanziWriter.totalStrokes = charData.rawCharData.medians.length;
                    console.log(`Set totalStrokes to ${hanziWriter.totalStrokes} from medians in processSingleCharacter`);
                } else if (charData) {
                    hanziWriter.totalStrokes = charData.totalStrokes || (charData.strokes ? charData.strokes.length : 0);
                    console.log(`Set totalStrokes to ${hanziWriter.totalStrokes} from structure in processSingleCharacter`);
                }
            }
            
            // Initialize canvas (character is shown, ready for drag/touch)
            setTimeout(() => {
                hanziWriter.initCanvas();
                // Wait a bit to ensure canvas is fully initialized and guide is drawn
                setTimeout(() => {
                    updateProgressDisplay();
                    console.log(`Character ${character} displayed. Drag or touch anywhere to draw strokes...`);
                }, 50);
            }, 100);
        }
        
        function onCharacterCompleted() {
            // Prevent duplicate calls
            if (isCompletingCharacter) {
                console.log('Character completion already in progress, skipping duplicate call');
                return;
            }
            isCompletingCharacter = true;
            
            // Called when all strokes of current character are completed
            console.log(`Character ${character} completed! Moving to next character...`);
            
            // Capture the completed character and add it to the top right corner
            if (hanziWriter.canvas && hanziWriter.ctx) {
                const characterWrapper = document.querySelector('.character-wrapper');
                const container = document.getElementById('completed-characters-container');
                
                if (!characterWrapper || !container) return;
                
                // Step 1: Add explosive shining animation to the canvas
                characterWrapper.classList.add('shining');
                
                // Step 2: Capture the canvas after shine animation
                setTimeout(() => {
                    // Create a temporary canvas to capture the current state
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = hanziWriter.canvas.width;
                    tempCanvas.height = hanziWriter.canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw the current canvas content to the temp canvas
                    tempCtx.drawImage(hanziWriter.canvas, 0, 0);
                    
                    // Create a new canvas for the 36x36 thumbnail
                    const thumbnailCanvas = document.createElement('canvas');
                    thumbnailCanvas.width = 36;
                    thumbnailCanvas.height = 36;
                    const thumbnailCtx = thumbnailCanvas.getContext('2d');
                    
                    // Draw the temp canvas scaled down to 36x36
                    thumbnailCtx.drawImage(tempCanvas, 0, 0, 36, 36);
                    
                    // Convert to image data URL
                    const imageDataUrl = thumbnailCanvas.toDataURL('image/png');
                    
                    // Get positions for animation
                    const wrapperRect = characterWrapper.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    // Calculate target position (top-right of container, accounting for new item)
                    const targetX = containerRect.right - 46; // 36px + 10px padding
                    const targetY = containerRect.top + 10 + (container.children.length % 20) * 36;
                    
                    // Step 3: Create flying thumbnail
                    const flyingImg = document.createElement('img');
                    flyingImg.src = imageDataUrl;
                    flyingImg.className = 'flying-thumbnail';
                    flyingImg.style.width = `${wrapperRect.width}px`;
                    flyingImg.style.height = `${wrapperRect.height}px`;
                    flyingImg.style.left = `${wrapperRect.left + wrapperRect.width / 2}px`;
                    flyingImg.style.top = `${wrapperRect.top + wrapperRect.height / 2}px`;
                    flyingImg.style.transform = 'translate(-50%, -50%)';
                    document.body.appendChild(flyingImg);
                    
                    // Remove shine class
                    characterWrapper.classList.remove('shining');
                    
                    // Start loading next character immediately (before flying animation starts)
                    const nextIndex = currentCharacterIndex + 1;
                    if (nextIndex < charactersToLearn.length) {
                        // Start loading next character right away so guide animation begins before flying
                        isCompletingCharacter = false; // Reset flag before processing next character
                        processSingleCharacter(nextIndex);
                    }
                    
                    // Step 4: Animate flying thumbnail to container (starts after next character begins loading)
                    setTimeout(() => {
                        flyingImg.style.left = `${targetX}px`;
                        flyingImg.style.top = `${targetY}px`;
                        flyingImg.style.width = '36px';
                        flyingImg.style.height = '36px';
                        flyingImg.style.transform = 'translate(-50%, -50%) scale(0.8)';
                        flyingImg.style.opacity = '0.9';
                    }, 10);
                    
                    // Step 5: After animation completes, add final thumbnail and remove flying one
                    setTimeout(() => {
                        // Play simple completion sound effect
                        playCompletionSound();
                        
                        // Create final thumbnail element
                        const img = document.createElement('img');
                        img.src = imageDataUrl;
                        img.alt = character;
                        
                        const completedDiv = document.createElement('div');
                        completedDiv.className = 'completed-character';
                        completedDiv.appendChild(img);
                        
                        container.appendChild(completedDiv);
                        
                        // Container height is automatically managed by top/bottom positioning
                        container.style.overflow = 'hidden';
                        
                        // Remove flying thumbnail
                        flyingImg.remove();
                        
                        // Update main canvas position based on container width
                        updateMainCanvasPosition();
                    }, 700); // Wait for animation to complete
                    
                    // Handle case when all characters are completed
                    if (nextIndex >= charactersToLearn.length) {
                        setTimeout(() => {
                            console.log('All characters completed!');
                            isCompletingCharacter = false; // Reset flag
                            
                            // Check if we're in level mode
                            if (currentLevel) {
                                onLevelComplete();
                            } else {
                                // Reset to first character when all are completed
                                saveCharacterIndex(0);
                            }
                        }, 700); // After flying animation completes
                    }
                }, 800); // Wait for shine animation to complete
            } else {
                // If canvas not available, just move to next character immediately
                const nextIndex = currentCharacterIndex + 1;
                if (nextIndex < charactersToLearn.length) {
                    isCompletingCharacter = false;
                    processSingleCharacter(nextIndex);
                } else {
                    isCompletingCharacter = false;
                    
                    // Check if we're in level mode
                    if (currentLevel) {
                        onLevelComplete();
                    } else {
                        saveCharacterIndex(0);
                    }
                }
            }
        }
        
        function moveToNextCharacter() {
            // Legacy function - now uses processSingleCharacter
            onCharacterCompleted();
        }
        
        function updateProgressDisplay() {
            const infoDisplay = document.getElementById('next-stroke-btn');
            if (infoDisplay) {
                const currentChar = charactersToLearn[currentCharacterIndex] || '';
                const levelName = currentLevel ? currentLevel.name : 'Practice';
                infoDisplay.textContent = `${levelName} ${currentCharacterIndex + 1}/${charactersToLearn.length} (${currentChar})`;
            }
        }
        
        // Update main canvas position based on container width
        function updateMainCanvasPosition() {
            const wrapper = document.getElementById('canvas-container-wrapper');
            const container = document.getElementById('completed-characters-container');
            const characterWrapper = document.querySelector('.character-wrapper');
            const mainContent = document.querySelector('.main-content');
            
            if (wrapper && container && characterWrapper && mainContent) {
                // Update container width first to ensure it's based on content
                updateContainerWidth();
                
                // Get container width (including padding) after updating
                const containerWidth = container.offsetWidth;
                // Get canvas width
                const canvasWidth = characterWrapper.offsetWidth || 800;
                // Get available viewport width
                const viewportWidth = window.innerWidth;
                // Calculate minimum space needed (canvas + container + gaps + margins)
                const minSpaceNeeded = canvasWidth + containerWidth + 60; // 60px for gaps and margins
                
                // Check if we need vertical layout
                if (viewportWidth < minSpaceNeeded) {
                    // Not enough horizontal space - use vertical layout
                    wrapper.classList.remove('horizontal-layout');
                    wrapper.classList.add('vertical-layout');
                    mainContent.style.marginRight = '0';
                    
                    // Update grid layout for vertical mode
                    if (currentLevel && currentLevel.numCharacters) {
                        setCompletedCharactersLayout(currentLevel.numCharacters);
                    }
                } else {
                    // Enough space - use horizontal layout
                    wrapper.classList.remove('vertical-layout');
                    wrapper.classList.add('horizontal-layout');
                    // Ensure container width is recalculated for horizontal layout
                    updateContainerWidth();
                    // Add right margin to reserve space for container, keeping canvas centered in remaining space
                    const totalOffset = containerWidth + 20;
                    mainContent.style.marginRight = `${totalOffset}px`;
                    
                    // Update grid layout for horizontal mode
                    if (currentLevel && currentLevel.numCharacters) {
                        setCompletedCharactersLayout(currentLevel.numCharacters);
                    }
                }
            }
        }
        
        async function drawNextStroke() {
            if (!hanziWriter.canvas || !hanziWriter.ctx) {
                console.error('Canvas not initialized');
                alert('Canvas not initialized. Please refresh the page.');
                return;
            }
            
            // Get total strokes from our loaded structure
            if (hanziWriter.totalStrokes === 0) {
                console.log('totalStrokes is 0, trying to get from structure...');
                console.log('current character:', character);
                
                // First, try to reload from structure if not initialized
                if (!hanziWriter.strokeData.initialized || !hanziWriter.strokeData.rawCharData) {
                    console.log('strokeData not initialized, reloading from structure...');
                    if (!loadCharacterDataFromStructure(character)) {
                        console.error(`Failed to reload character data for: ${character}`);
                        alert(`Failed to load stroke data for ${character}`);
                        return;
                    }
                }
                
                // Try to get from medians
                if (hanziWriter.strokeData.rawCharData && hanziWriter.strokeData.rawCharData.medians) {
                    hanziWriter.totalStrokes = hanziWriter.strokeData.rawCharData.medians.length;
                    console.log(`‚úì Found ${hanziWriter.totalStrokes} strokes from medians`);
                } else {
                    // Try to get from structure
                    const charData = charactersStrokeDataList.find(c => c.character === character);
                    if (charData && charData.rawCharData && charData.rawCharData.medians) {
                        hanziWriter.totalStrokes = charData.rawCharData.medians.length;
                        console.log(`‚úì Found ${hanziWriter.totalStrokes} strokes from structure medians`);
                    } else if (charData) {
                        hanziWriter.totalStrokes = charData.totalStrokes || 0;
                        console.log(`‚úì Found ${hanziWriter.totalStrokes} strokes from structure totalStrokes`);
                    }
                }
                
                // Final check
                if (hanziWriter.totalStrokes === 0) {
                    console.error('No stroke data available');
                    alert(`No stroke data available for ${character}`);
                    return;
                }
            }
            
            // Check if all strokes are done (but only if not already completing)
            if (hanziWriter.currentStrokeIndex >= hanziWriter.totalStrokes && !isCompletingCharacter) {
                console.log('All strokes done, moving to next character');
                onCharacterCompleted();
                return;
            }
            
            if (hanziWriter.isAnimating) {
                console.log('Already animating, ignoring click');
                return;
            }
            
            const infoDisplay = document.getElementById('next-stroke-btn');
            const strokeNum = hanziWriter.currentStrokeIndex;
            
            console.log(`=== About to draw stroke ${strokeNum + 1}/${hanziWriter.totalStrokes} ===`);
            
            // Set isAnimating flag early to prevent race conditions
            // It will be set again in drawStroke, but this ensures immediate protection
            hanziWriter.isAnimating = true;
            
            if (infoDisplay) {
                const currentChar = charactersToLearn[currentCharacterIndex] || '';
                const levelName = currentLevel ? currentLevel.name : 'Practice';
                infoDisplay.textContent = `${levelName} ${currentCharacterIndex + 1}/${charactersToLearn.length} (${currentChar})`;
            }
            
            try {
                // If this is the first stroke, ensure guide character is drawn first
                if (strokeNum === 0 && hanziWriter.drawnStrokes.length === 0) {
                    // Ensure guide character is drawn on guide canvas before first stroke
                    if (hanziWriter.guideCtx && hanziWriter.strokeData.rawCharData && hanziWriter.strokeData.rawCharData.medians) {
                        hanziWriter.drawGuideCharacter();
                        // Reset stroke style
                        hanziWriter.ctx.strokeStyle = '#1C1C1C'; // Drawing color
                        hanziWriter.ctx.lineWidth = 25;
                        // Small delay to ensure guide is rendered
                        await new Promise(resolve => setTimeout(resolve, 30));
                        // Set currentStrokeIndex to zero after guide is prepared
                        hanziWriter.currentStrokeIndex = 0;
                    }
                }
                
                // Draw the stroke
                hanziWriter.drawStroke(strokeNum, true); // true = animate
                
                // Mark stroke as drawn
                if (!hanziWriter.drawnStrokes.includes(strokeNum)) {
                    hanziWriter.drawnStrokes.push(strokeNum);
                }
                
                // Wait for animation to complete (check every 50ms)
                let checkCount = 0;
                const maxChecks = 200; // Maximum 10 seconds (200 * 50ms)
                function checkAnimationComplete() {
                    checkCount++;
                    if (checkCount > maxChecks) {
                        console.error('Animation check timeout - forcing completion');
                        hanziWriter.isAnimating = false;
                        // Mark stroke as drawn now that animation is complete
                        if (!hanziWriter.drawnStrokes.includes(strokeNum)) {
                            hanziWriter.drawnStrokes.push(strokeNum);
                        }
                        hanziWriter.currentStrokeIndex++;
                        updateProgressDisplay();
                        if (hanziWriter.currentStrokeIndex >= hanziWriter.totalStrokes) {
                            setTimeout(() => {
                                onCharacterCompleted();
                            }, 500);
                        }
                        return;
                    }
                    
                    if (!hanziWriter.isAnimating) {
                        // Animation completed - NOW increment the index
                        hanziWriter.currentStrokeIndex++;
                        
                        updateProgressDisplay();
                        
                        if (hanziWriter.currentStrokeIndex >= hanziWriter.totalStrokes) {
                            console.log('All strokes completed for this character');
                            setTimeout(() => {
                                onCharacterCompleted();
                            }, 500);
                        }
                    } else {
                        // Still animating, check again
                        setTimeout(checkAnimationComplete, 50);
                    }
                }
                
                // Start checking after a short delay
                setTimeout(checkAnimationComplete, 100);
                
            } catch (e) {
                console.error('Error drawing stroke:', e);
                hanziWriter.isAnimating = false;
                updateProgressDisplay();
                alert('Error drawing stroke: ' + e.message);
            }
        }

        // Function to calculate how many strokes to draw based on drag distance
        function calculateStrokesFromDragDistance(dragDistance) {
            // Default to 1 stroke if stroke data not available
            if (!hanziWriter.strokeData.initialized || !hanziWriter.strokeData.strokes) {
                return 1;
            }
            
            const currentIndex = hanziWriter.currentStrokeIndex;
            const remainingStrokes = hanziWriter.totalStrokes - currentIndex;
            
            if (remainingStrokes <= 0) {
                return 0;
            }
            
            // Calculate canvas scale to convert stroke lengths from data coordinates to screen pixels
            const canvas = hanziWriter.canvas;
            if (!canvas) {
                return 1;
            }
            
            const canvasSize = canvas.width;
            const dataWidth = 900;
            const dataHeight = 900;
            const strokeHalfWidth = 25 / 2; // lineWidth / 2
            const padding = Math.max(strokeHalfWidth + 10, canvasSize * 0.1);
            const availableSize = canvasSize - (padding * 2);
            const scale = availableSize / Math.max(dataWidth, dataHeight);
            
            // Calculate cumulative lengths including distances between strokes (in screen pixels)
            // Formula: d > stroke1.length + stroke1.distanceToNext + stroke2.length + ... to draw multiple strokes
            let cumulativeLength = 0;
            let strokeCount = 0;
            
            for (let i = currentIndex; i < Math.min(currentIndex + remainingStrokes, hanziWriter.strokeData.strokes.length); i++) {
                const stroke = hanziWriter.strokeData.strokes[i];
                if (stroke && stroke.length !== null && stroke.length !== undefined) {
                    // Convert stroke length from data coordinates to screen pixels
                    const strokeLengthScreen = stroke.length * scale;
                    
                    // Calculate cumulative length including distance to this stroke
                    // Formula: d > stroke1.length + stroke1.distanceToNext + stroke2.length + ...
                    // For the first stroke: cumulative = stroke1.length
                    // For subsequent strokes: cumulative = previous + previousStroke.distanceToNext + current stroke length
                    let newCumulativeLength;
                    if (strokeCount === 0) {
                        // First stroke: just add its length
                        newCumulativeLength = strokeLengthScreen;
                    } else {
                        // Subsequent stroke: add distance from previous stroke to this one, then add current stroke length
                        const previousStroke = hanziWriter.strokeData.strokes[i - 1];
                        let distanceToNextScreen = 0;
                        if (previousStroke && previousStroke.distanceToNext !== null && previousStroke.distanceToNext !== undefined) {
                            distanceToNextScreen = previousStroke.distanceToNext * scale;
                        }
                        newCumulativeLength = cumulativeLength + distanceToNextScreen + strokeLengthScreen;
                    }
                    
                    // If drag distance is >= cumulative length including this stroke and distance to it, include it
                    if (dragDistance >= newCumulativeLength) {
                        cumulativeLength = newCumulativeLength;
                        strokeCount++;
                        // Continue to check if we can include more strokes
                    } else {
                        // Drag distance is less than cumulative length including this stroke
                        // Stop here - we've found the maximum number of strokes
                        break;
                    }
                } else {
                    // If stroke length is not available, break (default to existing strokeCount)
                    break;
                }
            }
            
            // Ensure at least 1 stroke is drawn if drag distance meets minimum
            const strokesToDraw = Math.max(1, strokeCount);
            
            // Don't draw more strokes than remaining
            return Math.min(strokesToDraw, remainingStrokes);
        }
        
        // Function to calculate angle of user movement
        function checkStrokeSimilarity(userPath, strokeIndex) {
            let result = {
                userAngle: null,
                strokeAngle: null,
                similarity: 0.5
            };
            
            if (!userPath || userPath.length < 2) {
                console.log('User path too short:', userPath ? userPath.length : 'null');
                return result;
            }
            
            // Get user movement start and end points from screen coordinates
            // Screen coordinates: (0,0) at top-left, y increases downward
            const userStart = userPath[0];
            const userEnd = userPath[userPath.length - 1];
            
            console.log('User path start:', userStart, 'User path end:', userEnd);
            console.log('User path length:', userPath.length);
            
            // Calculate direction vector (angle) - using screen coordinates
            const userDx = userEnd.x - userStart.x;
            const userDy = userEnd.y - userStart.y;
            
            console.log('User dx:', userDx, 'User dy:', userDy);
            
            // Calculate angle in radians using atan2
            // User coordinates: (0,0) at top-left, y increases downward
            result.userAngle = Math.atan2(userDy, userDx);
            
            console.log('User angle (radians):', result.userAngle);
            console.log('User angle (degrees):', result.userAngle * 180 / Math.PI);
            
            // Get stroke angle from stored stroke data
            if (hanziWriter.strokeData.initialized && hanziWriter.strokeData.strokes[strokeIndex]) {
                const storedStroke = hanziWriter.strokeData.strokes[strokeIndex];
                result.strokeAngle = storedStroke.angle;
                console.log('Stroke angle from stored data:', storedStroke.angle);
                console.log('Stroke angle (degrees):', storedStroke.angleDegrees);
            } else {
                console.log('Stroke data not initialized or stroke not found:', {
                    initialized: hanziWriter.strokeData.initialized,
                    strokeIndex: strokeIndex,
                    strokesLength: hanziWriter.strokeData.strokes ? hanziWriter.strokeData.strokes.length : 0
                });
            }
            
            return result;
        }


        // Function to check if user's drag direction matches stroke direction
        function checkDragDirection(dragStartX, dragStartY, dragEndX, dragEndY, strokeIndex) {
            // Calculate user's drag angle in degrees
            const dx = dragEndX - dragStartX;
            const dy = dragEndY - dragStartY;
            const userDragAngle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            // Get the stroke's angle from strokeData
            if (!hanziWriter.strokeData.strokes || !hanziWriter.strokeData.strokes[strokeIndex]) {
                return null;
            }
            
            const stroke = hanziWriter.strokeData.strokes[strokeIndex];
            const strokeAngle = stroke.angleDegrees;
            
            if (strokeAngle === null || strokeAngle === undefined) {
                return null;
            }
            
            // Calculate the absolute difference between angles
            // Handle angle wrapping (e.g., -179 and 179 are actually 2 degrees apart)
            let angleDifference = Math.abs(userDragAngle - strokeAngle);
            if (angleDifference > 180) {
                angleDifference = 360 - angleDifference;
            }
            
            // Display the angles
            console.log(`User drag degree: ${userDragAngle.toFixed(2)}¬∞`);
            console.log(`Stroke degree: ${strokeAngle.toFixed(2)}¬∞`);
            
            // Check if within 30 degrees
            if (angleDifference <= 30) {
                console.log('perfect');
                // Increase HP by 1 when perfect
                updateHPBar(currentHP + 1);
            } else {
                console.log('not good');
            }
            
            // Return the angle difference for punishment calculation
            return angleDifference;
        }

        // Function to calculate punishment based on degree difference and strokes drawn
        function calculatePunishment(angleDifference, strokeIndex, numberOfStrokesDrawn, dragDistance) {
            // No punishment if within 30 degrees
            if (angleDifference <= 30) {
                return 0;
            }
            
            // Special case: if drawing more than 5 strokes and drag is too long
            if (numberOfStrokesDrawn > 5) {
                // Calculate sum of remaining strokes
                const remainingStrokes = hanziWriter.totalStrokes - strokeIndex;
                if (hanziWriter.strokeData.strokes && remainingStrokes > 0) {
                    // Get canvas scale
                    const canvas = hanziWriter.canvas;
                    if (canvas) {
                        const canvasSize = canvas.width;
                        const dataWidth = 900;
                        const dataHeight = 900;
                        const strokeHalfWidth = 25 / 2;
                        const padding = Math.max(strokeHalfWidth + 10, canvasSize * 0.1);
                        const availableSize = canvasSize - (padding * 2);
                        const scale = availableSize / Math.max(dataWidth, dataHeight);
                        
                        // Calculate sum of remaining stroke lengths (in screen pixels)
                        let sumRemainingStrokes = 0;
                        for (let i = strokeIndex; i < Math.min(strokeIndex + remainingStrokes, hanziWriter.strokeData.strokes.length); i++) {
                            const stroke = hanziWriter.strokeData.strokes[i];
                            if (stroke && stroke.length) {
                                sumRemainingStrokes += stroke.length * scale;
                            }
                        }
                        
                        // Check if drag distance > 130% of sum of remaining strokes
                        if (dragDistance > sumRemainingStrokes * 1.3) {
                            const bigPunishment = numberOfStrokesDrawn * 60;
                            console.log(`BIG PUNISHMENT: ${bigPunishment} = ${numberOfStrokesDrawn} strokes √ó 60 (drag too long: ${dragDistance.toFixed(2)}px > 130% of ${sumRemainingStrokes.toFixed(2)}px)`);
                            return bigPunishment;
                        }
                    }
                }
            }
            
            // Check exception: if exactly 2 strokes drawn AND second stroke is less than 50% of first stroke length
            if (numberOfStrokesDrawn === 2) {
                // Get first stroke and second stroke
                if (hanziWriter.strokeData.strokes && 
                    hanziWriter.strokeData.strokes[strokeIndex] && 
                    hanziWriter.strokeData.strokes[strokeIndex + 1]) {
                    
                    const firstStroke = hanziWriter.strokeData.strokes[strokeIndex];
                    const secondStroke = hanziWriter.strokeData.strokes[strokeIndex + 1];
                    
                    if (firstStroke.length && secondStroke.length) {
                        // If second stroke is less than 50% of first stroke length, no punishment
                        if (secondStroke.length < firstStroke.length * 0.5) {
                            console.log('No punishment: second stroke is short (< 50% of first stroke)');
                            return 0;
                        }
                    }
                }
            }
            
            // Calculate punishment: (degree difference - 30) * number of strokes drawn
            const punishment = Math.abs(angleDifference - 30) * numberOfStrokesDrawn;
            console.log(`Punishment: ${punishment.toFixed(2)} = (${angleDifference.toFixed(2)}¬∞ - 30¬∞) √ó ${numberOfStrokesDrawn} strokes`);
            
            return punishment;
        }

        // Add drag/touch detection anywhere on the page - any drag/touch draws next stroke
        function initDragDetection() {
            let isDragging = false;
            let hasTriggered = false; // Prevent multiple triggers from same drag
            let startX = 0;
            let startY = 0;
            let dragPath = []; // Track all points during drag to calculate total distance
            const MIN_DRAG_DISTANCE = 30; // Minimum distance in pixels to trigger stroke drawing

            function getEventCoordinates(e) {
                // Handle both mouse and touch events
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                } else {
                    return { x: e.clientX, y: e.clientY };
                }
            }
            
            // Calculate total distance along the drag path (including all turns)
            function calculateTotalDragDistance(path) {
                if (!path || path.length < 2) {
                    return 0;
                }
                
                let totalDistance = 0;
                for (let i = 1; i < path.length; i++) {
                    const prevPoint = path[i - 1];
                    const currPoint = path[i];
                    const dx = currPoint.x - prevPoint.x;
                    const dy = currPoint.y - prevPoint.y;
                    const segmentDistance = Math.sqrt(dx * dx + dy * dy);
                    totalDistance += segmentDistance;
                }
                
                return totalDistance;
            }

            function handleStart(e) {
                // Check if level selection overlay is visible
                const levelSelectionOverlay = document.getElementById('level-selection-overlay');
                if (levelSelectionOverlay && !levelSelectionOverlay.classList.contains('hidden')) {
                    return; // Don't handle drag if level selection is visible
                }
                
                // Check if game over overlay is visible
                const gameOverOverlay = document.getElementById('game-over-overlay');
                if (gameOverOverlay && !gameOverOverlay.classList.contains('hidden')) {
                    return; // Don't handle drag if game over is visible
                }
                
                // Check if level complete overlay is visible
                const levelCompleteOverlay = document.getElementById('level-complete-overlay');
                if (levelCompleteOverlay && !levelCompleteOverlay.classList.contains('hidden')) {
                    return; // Don't handle drag if level complete is visible
                }
                
                // Don't trigger on button clicks, UI elements, or overlay screens
                if (e.target && (
                    e.target.id === 'next-stroke-btn' || 
                    (e.target.closest && e.target.closest('#next-stroke-btn')) ||
                    e.target.id === 'music-toggle' ||
                    (e.target.closest && e.target.closest('#music-toggle')) ||
                    (e.target.closest && e.target.closest('.music-control')) ||
                    e.target.id === 'voice-btn' ||
                    (e.target.closest && e.target.closest('#voice-btn'))
                )) {
                    return;
                }
                // Prevent text selection during drag
                e.preventDefault();
                const coords = getEventCoordinates(e);
                startX = coords.x;
                startY = coords.y;
                // Initialize drag path with start point
                dragPath = [{ x: startX, y: startY }];
                isDragging = true;
                hasTriggered = false;
            }

            function handleMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                // Track intermediate points during drag
                const coords = getEventCoordinates(e);
                dragPath.push({ x: coords.x, y: coords.y });
            }

            async function handleEnd(e) {
                // Check if level selection overlay is visible
                const levelSelectionOverlay = document.getElementById('level-selection-overlay');
                if (levelSelectionOverlay && !levelSelectionOverlay.classList.contains('hidden')) {
                    isDragging = false;
                    return; // Don't handle drag if level selection is visible
                }
                
                // Check if game over overlay is visible
                const gameOverOverlay = document.getElementById('game-over-overlay');
                if (gameOverOverlay && !gameOverOverlay.classList.contains('hidden')) {
                    isDragging = false;
                    return; // Don't handle drag if game over is visible
                }
                
                // Check if level complete overlay is visible
                const levelCompleteOverlay = document.getElementById('level-complete-overlay');
                if (levelCompleteOverlay && !levelCompleteOverlay.classList.contains('hidden')) {
                    isDragging = false;
                    return; // Don't handle drag if level complete is visible
                }
                
                // Don't trigger on button clicks or UI elements
                if (e.target && (
                    e.target.id === 'next-stroke-btn' || 
                    (e.target.closest && e.target.closest('#next-stroke-btn')) ||
                    e.target.id === 'music-toggle' ||
                    (e.target.closest && e.target.closest('#music-toggle')) ||
                    (e.target.closest && e.target.closest('.music-control')) ||
                    e.target.id === 'voice-btn' ||
                    (e.target.closest && e.target.closest('#voice-btn'))
                )) {
                    isDragging = false;
                    return;
                }
                
                if (!isDragging || hasTriggered) {
                    isDragging = false;
                    hasTriggered = false;
                    return;
                }
                
                // Get end coordinates and add to path
                const coords = getEventCoordinates(e);
                const endX = coords.x;
                const endY = coords.y;
                
                // Add end point to drag path
                if (dragPath.length === 0 || 
                    dragPath[dragPath.length - 1].x !== endX || 
                    dragPath[dragPath.length - 1].y !== endY) {
                    dragPath.push({ x: endX, y: endY });
                }
                
                // Check if game is over
                if (isGameOver) {
                    isDragging = false;
                    hasTriggered = false;
                    dragPath = [];
                    return;
                }
                
                // Calculate total drag distance along the path (including all turns)
                const dragDistance = calculateTotalDragDistance(dragPath);
                
                // Only proceed if drag distance is greater than minimum threshold
                if (dragDistance < MIN_DRAG_DISTANCE) {
                    isDragging = false;
                    hasTriggered = false;
                    dragPath = []; // Reset drag path
                    return;
                }
                
                // Check if we can draw
                if (hanziWriter.isAnimating) {
                    isDragging = false;
                    hasTriggered = false;
                    dragPath = []; // Reset drag path
                    return;
                }
                
                if (!hanziWriter.canvas || !hanziWriter.ctx) {
                    isDragging = false;
                    hasTriggered = false;
                    dragPath = []; // Reset drag path
                    return;
                }
                
                // Check drag direction against current stroke direction
                const angleDifference = checkDragDirection(startX, startY, endX, endY, hanziWriter.currentStrokeIndex);
                
                // Calculate how many strokes to draw based on drag distance vs stroke lengths
                const strokesToDraw = calculateStrokesFromDragDistance(dragDistance);
                
                // Calculate punishment if we have a valid angle difference
                if (angleDifference !== null) {
                    const punishment = calculatePunishment(angleDifference, hanziWriter.currentStrokeIndex, strokesToDraw, dragDistance);
                    const hpDeduction = punishmentToHPDeduction(punishment);
                    if (hpDeduction > 0) {
                        applyDamage(hpDeduction);
                    }
                }
                
                hasTriggered = true;
                
                // Draw the calculated number of strokes
                const startStrokeIndex = hanziWriter.currentStrokeIndex;
                const targetStrokeIndex = Math.min(startStrokeIndex + strokesToDraw, hanziWriter.totalStrokes);
                
                for (let targetIndex = startStrokeIndex; targetIndex < targetStrokeIndex; targetIndex++) {
                    // Wait for animation to complete and index to catch up
                    while (hanziWriter.isAnimating || hanziWriter.currentStrokeIndex < targetIndex) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    // Double check we haven't completed all strokes
                    if (hanziWriter.currentStrokeIndex >= hanziWriter.totalStrokes) {
                        break;
                    }
                    
                    // Ensure we're drawing the correct stroke index
                    if (hanziWriter.currentStrokeIndex !== targetIndex) {
                        hanziWriter.currentStrokeIndex = targetIndex;
                    }
                    
                    await drawNextStroke();
                    
                    // If we've completed all strokes for this character, break
                    if (hanziWriter.currentStrokeIndex >= hanziWriter.totalStrokes) {
                        break;
                    }
                }
                
                isDragging = false;
                dragPath = []; // Reset drag path for next drag
                e.preventDefault();
            }

            // Mouse events
            document.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('mouseleave', handleEnd);

            // Touch events
            document.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('touchend', handleEnd, { passive: false });
            document.addEventListener('touchcancel', handleEnd, { passive: false });
        }

        // Start when page loads - only initialize drag detection
        // initializeApp() already handles canvas initialization
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                initDragDetection();
            });
        } else {
            initDragDetection();
        }
    </script>
</body>
</html>
