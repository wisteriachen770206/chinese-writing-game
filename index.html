<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinese Character Homepage</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'SimHei', 'Arial', sans-serif;
            background-image: url('res/guanyin.jpg');
            background-repeat: repeat;
            background-size: auto;
            background-color: #F5F5F3; /* Fallback color */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: auto; /* Allow horizontal scrolling when needed */
            overflow-y: auto; /* Allow vertical scrolling when content exceeds viewport */
            position: relative;
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #F5F5F3;
            opacity: 0.7; /* Adjust opacity to control shading intensity */
            z-index: -1;
            pointer-events: none;
        }

        .top-bar {
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        
        .music-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            padding: 8px 15px;
            backdrop-filter: blur(10px);
            opacity: 0.3;
        }
        
        .music-toggle {
            width: 50px;
            height: 26px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .music-toggle.active {
            background: #4ade80;
        }
        
        .music-toggle::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        
        .music-toggle.active::after {
            transform: translateX(24px);
        }
        

        .main-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding: 20px;
            transition: margin-right 0.3s ease;
            min-width: fit-content; /* Allow content to determine minimum width */
        }
        
        .canvas-container-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 30px;
            position: relative;
        }
        
        .canvas-container-wrapper.horizontal-layout {
            flex-direction: row;
            align-items: center;
        }
        
        .canvas-container-wrapper.vertical-layout {
            flex-direction: column;
            align-items: center;
            overflow-x: auto; /* Allow horizontal scrolling if content is wider */
            overflow-y: visible; /* Let body handle vertical scrolling */
            width: 100%;
            padding-bottom: 20px; /* Add padding at bottom to ensure content is visible */
        }
        
        .container {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .debug-panel {
            display: none;
            width: 300px;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
            color: #ffffff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(10px);
        }

        .similarity-score {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 15px 30px;
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Microsoft YaHei', 'SimHei', 'Arial', sans-serif;
            backdrop-filter: blur(10px);
            z-index: 1000;
            text-align: center;
            min-width: 200px;
            transition: opacity 0.3s ease;
        }

        .similarity-score.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .similarity-score .label {
            font-size: 14px;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .similarity-score .value {
            font-size: 32px;
        }

        .similarity-score .value div {
            line-height: 1.4;
        }

        .similarity-score .good {
            color: #4ade80;
        }

        .similarity-score .medium {
            color: #fbbf24;
        }

        .similarity-score .poor {
            color: #f87171;
        }

        .debug-panel h3 {
            margin-bottom: 10px;
            font-size: 14px;
            color: #ffffff;
            text-align: center;
        }

        .debug-panel pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
        }

        .character-wrapper {
            position: relative;
            width: 80vmin;
            height: 80vmin;
            max-width: 800px;
            max-height: 800px;
            user-select: none; /* Prevent text selection */
        }

        #guide-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
            user-select: none; /* Prevent text selection */
        }

        #character-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            user-select: none; /* Prevent text selection */
        }


        #character-target {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        
        #character-target svg {
            width: 100% !important;
            height: 100% !important;
        }

        #next-stroke-btn {
            padding: 12px 28px;
            font-size: 15px;
            font-weight: 400;
            color: #9a9a9a;
            background: rgba(245, 245, 243, 0.6);
            border: 1px solid rgba(154, 154, 154, 0.2);
            border-radius: 20px;
            cursor: default;
            transition: all 0.3s ease;
            font-family: 'Microsoft YaHei', 'SimHei', 'Arial', sans-serif;
            letter-spacing: 0.5px;
            pointer-events: none; /* Make it non-clickable */
            user-select: none; /* Prevent text selection */
            opacity: 0.7;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            backdrop-filter: blur(8px);
            line-height: 1.4;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        #completed-characters-container {
            display: grid;
            grid-auto-flow: column;
            grid-template-rows: repeat(20, 36px); /* 36px height, no gap */
            gap: 0;
            z-index: 1000;
            overflow: hidden; /* Never show scrollbar */
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            direction: rtl; /* Makes new columns appear on the left */
            width: fit-content; /* Width based on content (number of columns) */
            min-width: fit-content;
            max-width: fit-content;
        }
        
        .canvas-container-wrapper.horizontal-layout #completed-characters-container {
            position: fixed;
            top: 20px;
            right: 20px;
            bottom: 20px;
            height: calc(100vh - 40px); /* 20px top + 20px bottom = 40px total */
        }
        
        .canvas-container-wrapper.vertical-layout #completed-characters-container {
            position: relative;
            margin-top: 30px;
            margin-bottom: 20px;
            height: auto; /* Grow naturally to show all content */
            min-height: 50px; /* Minimum height so it's visible even when empty */
            overflow-y: visible; /* Show all content vertically, let browser handle scrolling */
            width: fit-content; /* Grow to fit all content */
            min-width: 36px; /* At least one column width */
            display: grid; /* Ensure grid display is maintained */
            visibility: visible; /* Ensure it's visible */
        }

        .completed-character {
            width: 36px;
            height: 36px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .completed-character img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        /* Shining animation for completed character */
        @keyframes explosiveShine {
            0% {
                transform: scale(1);
                filter: brightness(1) drop-shadow(0 0 0px rgba(255, 255, 0, 0));
            }
            25% {
                transform: scale(1.15);
                filter: brightness(2) drop-shadow(0 0 40px rgba(255, 255, 0, 1)) drop-shadow(0 0 80px rgba(255, 200, 0, 0.8));
            }
            50% {
                transform: scale(1.1) rotate(5deg);
                filter: brightness(2.5) drop-shadow(0 0 60px rgba(255, 255, 255, 1)) drop-shadow(0 0 100px rgba(255, 200, 0, 1));
            }
            75% {
                transform: scale(1.2) rotate(-3deg);
                filter: brightness(2) drop-shadow(0 0 50px rgba(255, 255, 0, 0.9));
            }
            100% {
                transform: scale(1);
                filter: brightness(1) drop-shadow(0 0 0px rgba(255, 255, 0, 0));
            }
        }
        
        .character-wrapper.shining {
            animation: explosiveShine 0.8s ease-out;
            z-index: 9999;
        }
        
        /* Animated character thumbnail flying to container */
        .flying-thumbnail {
            position: fixed;
            z-index: 10000;
            pointer-events: none;
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @media (max-width: 768px) {
            .character-wrapper {
                width: 90vmin;
                height: 90vmin;
            }
        }

        @media (min-width: 1200px) {
            .character-wrapper {
                width: 70vmin;
                height: 70vmin;
            }
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div id="next-stroke-btn">Next Stroke</div>
        <div class="music-control">
            <div class="music-icon">ðŸŽµ</div>
            <div class="music-toggle" id="music-toggle"></div>
        </div>
    </div>
    
    <!-- Background music -->
    <audio id="background-music" loop>
        <source src="res/xj0106.mp3" type="audio/mpeg">
    </audio>
    <!-- Completion sound effect -->
    <audio id="completion-sound" preload="auto">
        <!-- You can add your sound file here, e.g. <source src="res/completion.mp3" type="audio/mpeg"> -->
    </audio>
    <div id="similarity-score" class="similarity-score hidden">
        <div class="label">Similarity Score</div>
        <div class="value" id="similarity-value">0%</div>
    </div>
    <div class="main-content">
        <div class="canvas-container-wrapper horizontal-layout" id="canvas-container-wrapper">
            <div class="container">
                <div class="character-wrapper">
                    <canvas id="guide-canvas"></canvas>
                    <canvas id="character-canvas"></canvas>
                </div>
            </div>
            <div id="completed-characters-container"></div>
        </div>
        <div class="debug-panel">
            <h3>Character Data (Debug)</h3>
            <pre id="stroke-data-debug">Loading...</pre>
        </div>
    </div>

    <script>
        // Character learning mode - all characters from ToWriteText.txt
        let charactersToLearn = []; // Will be populated from all_strokes.json
        let currentCharacterIndex = 0;
        let character = '';
        let appInitialized = false; // Track if app has been initialized
        let isCompletingCharacter = false; // Prevent duplicate calls to onCharacterCompleted
        
        // LocalStorage key for saving progress
        const STORAGE_KEY = 'hanziWriter_currentCharacterIndex';
        
        // Load saved character index from localStorage
        function loadSavedCharacterIndex() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved !== null) {
                    const index = parseInt(saved, 10);
                    if (!isNaN(index) && index >= 0) {
                        console.log(`Loaded saved character index: ${index}`);
                        return index;
                    }
                }
            } catch (e) {
                console.warn('Could not load saved character index:', e);
            }
            return 0; // Default to first character
        }
        
        // Save current character index to localStorage
        function saveCharacterIndex(index) {
            try {
                localStorage.setItem(STORAGE_KEY, index.toString());
                console.log(`Saved character index: ${index}`);
            } catch (e) {
                console.warn('Could not save character index:', e);
            }
        }
        
        // Generate thumbnail for a character from stroke data
        function generateCharacterThumbnail(char, charData) {
            if (!charData || !charData.rawCharData || !charData.rawCharData.medians) {
                console.warn(`Cannot generate thumbnail for ${char}: missing stroke data`);
                return null;
            }
            
            // Create a temporary canvas to draw the character
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 420; // Use same size as main canvas
            tempCanvas.height = 420;
            const tempCtx = tempCanvas.getContext('2d');
            
            if (!tempCtx) return null;
            
            // Clear canvas
            tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Set drawing style
            tempCtx.strokeStyle = '#1C1C1C'; // Drawing color
            tempCtx.lineWidth = 15;
            tempCtx.lineCap = 'round';
            tempCtx.lineJoin = 'round';
            
            const medians = charData.rawCharData.medians;
            const canvasSize = tempCanvas.width;
            const dataWidth = 900;
            const dataHeight = 900;
            const strokeHalfWidth = 15 / 2;
            const padding = Math.max(strokeHalfWidth + 10, canvasSize * 0.1);
            const availableSize = canvasSize - (padding * 2);
            const scale = availableSize / Math.max(dataWidth, dataHeight);
            const offsetX = (canvasSize - (dataWidth * scale)) / 2;
            const offsetY = (canvasSize - (dataHeight * scale)) / 2;
            
            // Draw all strokes
            for (let i = 0; i < medians.length; i++) {
                const strokePoints = medians[i];
                if (!strokePoints || strokePoints.length === 0) continue;
                
                const canvasPoints = strokePoints.map(([x, y]) => {
                    return {
                        x: x * scale + offsetX,
                        y: (dataHeight - y) * scale + offsetY
                    };
                });
                
                tempCtx.beginPath();
                tempCtx.moveTo(canvasPoints[0].x, canvasPoints[0].y);
                for (let j = 1; j < canvasPoints.length; j++) {
                    tempCtx.lineTo(canvasPoints[j].x, canvasPoints[j].y);
                }
                tempCtx.stroke();
            }
            
            // Create thumbnail canvas (36x36)
            const thumbnailCanvas = document.createElement('canvas');
            thumbnailCanvas.width = 36;
            thumbnailCanvas.height = 36;
            const thumbnailCtx = thumbnailCanvas.getContext('2d');
            
            // Scale down to 36x36
            thumbnailCtx.drawImage(tempCanvas, 0, 0, 36, 36);
            
            // Convert to image data URL
            return thumbnailCanvas.toDataURL('image/png');
        }
        
        // Add thumbnail to container
        function addThumbnailToContainer(char, imageDataUrl) {
            const container = document.getElementById('completed-characters-container');
            if (!container) return;
            
            const img = document.createElement('img');
            img.src = imageDataUrl;
            img.alt = char;
            
            const completedDiv = document.createElement('div');
            completedDiv.className = 'completed-character';
            completedDiv.appendChild(img);
            
            container.appendChild(completedDiv);
            
            // Update container width based on number of columns
            updateContainerWidth();
        }
        
        // Update container width based on number of columns
        function updateContainerWidth() {
            const container = document.getElementById('completed-characters-container');
            if (!container) return;
            
            // Calculate number of columns (20 rows per column)
            const columnCount = Math.ceil(container.children.length / 20);
            const columnWidth = 36; // Each character is 36px wide
            const containerPadding = 20; // 10px left + 10px right
            const containerWidth = (columnCount * columnWidth) + containerPadding;
            
            container.style.width = `${containerWidth}px`;
            container.style.minWidth = `${containerWidth}px`;
            container.style.maxWidth = `${containerWidth}px`;
        }
        
        // Load previous characters' thumbnails when resuming
        async function loadPreviousCharactersThumbnails(startIndex) {
            if (startIndex <= 0) return; // No previous characters
            
            console.log(`Loading thumbnails for previous ${startIndex} characters...`);
            
            for (let i = 0; i < startIndex; i++) {
                const char = charactersToLearn[i];
                const charData = charactersStrokeDataList.find(c => c.character === char);
                
                if (charData) {
                    const thumbnail = generateCharacterThumbnail(char, charData);
                    if (thumbnail) {
                        addThumbnailToContainer(char, thumbnail);
                        console.log(`Loaded thumbnail for character ${i + 1}: ${char}`);
                    }
                } else {
                    console.warn(`Could not find data for character ${i + 1}: ${char}`);
                }
            }
            
            // Update container width based on columns
            const container = document.getElementById('completed-characters-container');
            if (container) {
                container.style.overflow = 'hidden';
                updateContainerWidth();
            }
        }
        
        // Background music control
        let backgroundMusic = null;
        let musicEnabled = false;
        
        function initMusicControl() {
            backgroundMusic = document.getElementById('background-music');
            const musicToggle = document.getElementById('music-toggle');
            
            if (!backgroundMusic || !musicToggle) {
                console.warn('Music elements not found');
                return;
            }
            
            // Stop any existing audio first (in case of page refresh)
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0; // Reset to beginning
            
            // Set initial state
            musicToggle.classList.add('active');
            musicEnabled = true;
            
            // Try to play music (may require user interaction)
            backgroundMusic.volume = 0.5; // Set volume to 50%
            backgroundMusic.loop = true; // Ensure looping is enabled
            
            // Toggle music on/off
            musicToggle.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event from bubbling to drag detection
                e.preventDefault();
                musicEnabled = !musicEnabled;
                
                if (musicEnabled) {
                    musicToggle.classList.add('active');
                    backgroundMusic.play().catch(err => {
                        console.log('Could not play music:', err);
                        // If autoplay fails, user will need to interact first
                    });
                } else {
                    musicToggle.classList.remove('active');
                    backgroundMusic.pause();
                }
            });
            
            // Try to start music after first user interaction
            document.addEventListener('click', function startMusic() {
                if (musicEnabled && backgroundMusic.paused) {
                    backgroundMusic.play().catch(err => {
                        console.log('Could not autoplay music:', err);
                    });
                }
                // Remove listener after first click
                document.removeEventListener('click', startMusic);
            }, { once: true });
            
            console.log('Music control initialized');
        }
        
        
        // All characters stroke data loaded from all_strokes.json
        let allCharactersData = {};
        
        /**
         * Structured storage for stroke data - NEW STRUCTURE
         * 
         * CharacterStrokeData structure:
         * {
         *   character: string,           // The Chinese character
         *   unicode: number,             // Unicode code point
         *   unicodeHex: string,         // Unicode in hex format
         *   timestamp: string,          // ISO 8601 timestamp
         *   version: string,            // Data structure version
         *   source: string,             // Data source
         *   totalStrokes: number,       // Total number of strokes
         *   strokes: StrokeData[],      // Array of processed stroke data
         *   rawCharData: object         // Original unprocessed data
         * }
         * 
         * StrokeData structure:
         * {
         *   index: number,              // Stroke index (0-based)
         *   points: Point[],            // All points along stroke path
         *   pointCount: number,         // Number of points
         *   startPoint: Point,           // {x, y} - starting point
         *   endPoint: Point,            // {x, y} - ending point
         *   maxDistancePoint: Point,    // Point with max distance from start
         *   direction: {dx, dy},        // Direction vector
         *   angle: number,              // Angle in radians
         *   angleDegrees: number,       // Angle in degrees
         *   length: number,             // Total stroke length
         *   maxDistance: number,        // Max distance from start
         *   coordinateSystem: {         // Coordinate system info
         *     origin: string,           // "bottom-left" or "top-left"
         *     conversionHeight: number, // Reference height (e.g., 900)
         *     converted: boolean        // Whether converted to screen space
         *   },
         *   source: string,             // Data source: 'medians', 'path', 'points'
         *   processed: boolean,         // Whether processed
         *   switched: boolean,          // Whether start/end were switched
         *   rawData: any                // Original raw stroke data
         * }
         */
        
        // List to store first 5 characters in new structure
        let charactersStrokeDataList = [];
        
        // newHanziWriter class - encapsulates all drawing/writing functionality
        class newHanziWriter {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.guideCanvas = null;
                this.guideCtx = null;
                this.currentStrokeIndex = 0;
                this.totalStrokes = 0;
                this.isAnimating = false;
                this.drawnStrokes = [];
                this.guideDrawn = false; // Track if guide character has been drawn
                this.strokeData = {
                    character: null,
                    rawCharData: null,
                    strokes: [],
                    initialized: false
                };
            }
            
            initCanvas() {
                // Initialize main canvas for green strokes
                this.canvas = document.getElementById('character-canvas');
                if (!this.canvas) {
                    console.error('Canvas element not found');
                    return;
                }
                
                // Initialize guide canvas for background guide character
                this.guideCanvas = document.getElementById('guide-canvas');
                if (!this.guideCanvas) {
                    console.error('Guide canvas element not found');
                    return;
                }
                
                // Set canvas size to match container
                const wrapper = document.querySelector('.character-wrapper');
                const size = Math.min(wrapper.offsetWidth || 800, wrapper.offsetHeight || 800);
                this.canvas.width = size;
                this.canvas.height = size;
                this.guideCanvas.width = size;
                this.guideCanvas.height = size;
                
                this.ctx = this.canvas.getContext('2d');
                this.guideCtx = this.guideCanvas.getContext('2d');
                if (!this.ctx || !this.guideCtx) {
                    console.error('Could not get canvas context');
                    return;
                }
                
                // Clear main canvas (guide canvas stays as background)
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Set drawing style for main canvas
                this.ctx.strokeStyle = '#1C1C1C'; // Drawing color
                this.ctx.lineWidth = 25; // Larger strokes
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                console.log(`Canvas initialized: ${this.canvas.width}x${this.canvas.height}`);
                
                // Draw guide character on guide canvas if stroke data is available
                if (this.strokeData.rawCharData && this.strokeData.rawCharData.medians) {
                    this.drawGuideCharacter();
                    // Set currentStrokeIndex to zero after guide is prepared
                    this.currentStrokeIndex = 0;
                }
                
                const self = this;
                window.addEventListener('resize', () => {
                    const size = Math.min(wrapper.offsetWidth || 420, wrapper.offsetHeight || 420);
                    self.canvas.width = size;
                    self.canvas.height = size;
                    self.guideCanvas.width = size;
                    self.guideCanvas.height = size;
                    // Redraw guide on guide canvas
                    if (self.guideDrawn) {
                        self.drawGuideCharacter();
                    }
                    // Redraw all drawn strokes on main canvas
                    self.redrawAllStrokes();
                });
            }
            
            drawGuideCharacter() {
                if (!this.guideCtx || !this.strokeData.rawCharData || !this.strokeData.rawCharData.medians) return;
                
                const medians = this.strokeData.rawCharData.medians;
                if (medians.length === 0) return;
                
                // Clear guide canvas first
                this.guideCtx.clearRect(0, 0, this.guideCanvas.width, this.guideCanvas.height);
                
                // Get canvas dimensions and calculate scale/offset (same as drawStroke)
                const canvasSize = this.guideCanvas.width;
                const dataWidth = 900;
                const dataHeight = 900;
                const strokeHalfWidth = 25 / 2; // Use the actual stroke width for calculations
                const padding = Math.max(strokeHalfWidth + 10, canvasSize * 0.1);
                const availableSize = canvasSize - (padding * 2);
                const scale = availableSize / Math.max(dataWidth, dataHeight);
                const offsetX = (canvasSize - (dataWidth * scale)) / 2;
                const offsetY = (canvasSize - (dataHeight * scale)) / 2;
                
                // Draw all strokes in grey on guide canvas
                this.guideCtx.strokeStyle = '#9A9A9A'; // Guide character color
                this.guideCtx.lineWidth = 20; // Larger guide strokes
                this.guideCtx.lineCap = 'round';
                this.guideCtx.lineJoin = 'round';
                
                for (let i = 0; i < medians.length; i++) {
                    const strokePoints = medians[i];
                    if (!strokePoints || strokePoints.length === 0) continue;
                    
                    // Convert points to canvas coordinates
                    const canvasPoints = strokePoints.map(([x, y]) => {
                        return {
                            x: x * scale + offsetX,
                            y: (dataHeight - y) * scale + offsetY
                        };
                    });
                    
                    // Draw the stroke on guide canvas
                    this.guideCtx.beginPath();
                    this.guideCtx.moveTo(canvasPoints[0].x, canvasPoints[0].y);
                    for (let j = 1; j < canvasPoints.length; j++) {
                        this.guideCtx.lineTo(canvasPoints[j].x, canvasPoints[j].y);
                    }
                    this.guideCtx.stroke();
                }
                
                // Mark guide as drawn
                this.guideDrawn = true;
            }
            
            redrawAllStrokes() {
                if (!this.ctx || !this.strokeData.rawCharData) return;
                
                // Only clear and redraw the main canvas (green strokes)
                // Guide canvas stays as background, no need to redraw
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw all completed strokes in green on main canvas
                this.ctx.strokeStyle = '#1C1C1C'; // Drawing color
                this.ctx.lineWidth = 15; // Thinner strokes
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                // Redraw all previously drawn strokes
                for (let i = 0; i < this.drawnStrokes.length; i++) {
                    this.drawStroke(this.drawnStrokes[i], false); // false = no animation
                }
            }
            
            drawStroke(strokeIndex, animate = true) {
                if (!this.ctx || !this.strokeData.rawCharData || !this.strokeData.rawCharData.medians) {
                    console.error('Cannot draw stroke: missing data');
                    return;
                }
                
                // Set isAnimating flag IMMEDIATELY before starting animation
                // This prevents other operations from interfering
                if (animate) {
                    this.isAnimating = true;
                }
                
                // Ensure stroke style is set to bright green
                this.ctx.strokeStyle = '#1C1C1C'; // Drawing color // Bright green
                this.ctx.lineWidth = 25; // Larger strokes
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                
                const medians = this.strokeData.rawCharData.medians;
                if (strokeIndex >= medians.length) {
                    console.error(`Stroke index ${strokeIndex} out of range`);
                    return;
                }
                
                const strokePoints = medians[strokeIndex];
                if (!strokePoints || strokePoints.length === 0) {
                    console.error(`No points for stroke ${strokeIndex}`);
                    return;
                }
                
                // Get canvas dimensions and calculate scale/offset
                const canvasSize = this.canvas.width;
                const dataWidth = 900; // Standard width for character data
                const dataHeight = 900; // Standard height for character data
                
                // Account for stroke width (half on each side) and padding
                const strokeHalfWidth = this.ctx.lineWidth / 2;
                const padding = Math.max(strokeHalfWidth + 10, canvasSize * 0.1); // At least 10px + stroke width
                const availableSize = canvasSize - (padding * 2);
                
                // Scale to fit within available space
                const scale = availableSize / Math.max(dataWidth, dataHeight);
                
                // Center the character
                const offsetX = (canvasSize - (dataWidth * scale)) / 2;
                const offsetY = (canvasSize - (dataHeight * scale)) / 2;
                
                // Convert points from data coordinates to canvas coordinates
                // Data uses bottom-left origin, canvas uses top-left origin
                const canvasPoints = strokePoints.map(([x, y]) => {
                    return {
                        x: x * scale + offsetX,
                        y: (dataHeight - y) * scale + offsetY // Flip y-axis
                    };
                });
                
                if (animate) {
                    // Animate stroke drawing
                    this.animateStrokeDrawing(canvasPoints);
                } else {
                    // Draw immediately
                    this.ctx.beginPath();
                    this.ctx.moveTo(canvasPoints[0].x, canvasPoints[0].y);
                    for (let i = 1; i < canvasPoints.length; i++) {
                        this.ctx.lineTo(canvasPoints[i].x, canvasPoints[i].y);
                    }
                    this.ctx.stroke();
                }
            }
            
            animateStrokeDrawing(points) {
                if (points.length === 0) {
                    this.isAnimating = false;
                    return;
                }
                
                this.isAnimating = true;
                let currentIndex = 0;
                // Calculate animation speed based on stroke length for consistent timing
                // Aim for ~300ms animation time regardless of stroke length
                const targetDuration = 300; // milliseconds
                const fps = 60; // frames per second
                const totalFrames = Math.ceil((targetDuration / 1000) * fps);
                const animationSpeed = Math.max(1, Math.ceil(points.length / totalFrames));
                
                const self = this;
                function animate() {
                    if (currentIndex >= points.length) {
                        self.isAnimating = false;
                        return;
                    }
                    
                    self.ctx.beginPath();
                    self.ctx.moveTo(points[0].x, points[0].y);
                    
                    const endIndex = Math.min(currentIndex + animationSpeed, points.length);
                    for (let i = 1; i < endIndex; i++) {
                        self.ctx.lineTo(points[i].x, points[i].y);
                    }
                    self.ctx.stroke();
                    
                    currentIndex = endIndex;
                    
                    if (currentIndex < points.length) {
                        requestAnimationFrame(animate);
                    } else {
                        self.isAnimating = false;
                    }
                }
                
                animate();
            }
        }
        
        // Create global instance
        const hanziWriter = new newHanziWriter();

            // Function to calculate stroke angle from points
            function calculateStrokeAngle(points) {
                if (!points || points.length < 2) {
                    return null;
                }
                
                const startPoint = points[0];
                
                // Find the point with maximum distance from start point
                let maxDistance = 0;
                let endPoint = startPoint;
                let endPointIndex = 0;
                
                for (let i = 1; i < points.length; i++) {
                    const point = points[i];
                    const dx = point.x - startPoint.x;
                    const dy = point.y - startPoint.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        endPoint = point;
                        endPointIndex = i;
                    }
                }
                
                // Print start and end points to console
                console.log('Stroke start point:', startPoint);
                console.log('Stroke end point (max distance):', endPoint);
                console.log('Max distance:', maxDistance.toFixed(2));
                console.log('End point index:', endPointIndex, 'out of', points.length - 1);
                
                // Use start and end points directly (no switching)
                const finalStartPoint = startPoint;
                const finalEndPoint = endPoint;
                
                // Convert stroke coordinates from bottom-left origin to screen coordinates (top-left origin)
                // Stroke coordinates: (0,0) at bottom-left, y increases upward
                // Screen coordinates: (0,0) at top-left, y increases downward
                // Use 900 as the reference height for conversion
                const conversionHeight = 900;
                
                // Convert stroke points to screen coordinates
                let startPointScreen = {
                    x: finalStartPoint.x,
                    y: conversionHeight - finalStartPoint.y  // Flip y-axis
                };
                
                let endPointScreen = {
                    x: finalEndPoint.x,
                    y: conversionHeight - finalEndPoint.y  // Flip y-axis
                };
                
                console.log('Conversion height used:', conversionHeight);
                console.log('Stroke start point (original):', finalStartPoint);
                console.log('Stroke end point (original):', finalEndPoint);
                console.log('Stroke start point (converted to screen):', startPointScreen);
                console.log('Stroke end point (converted to screen):', endPointScreen);
                
                // Switch start and end points if endPoint x+y < startPoint x+y (after coordinate conversion)
                let finalStartPointScreen = startPointScreen;
                let finalEndPointScreen = endPointScreen;
                let switched = false;
                
                const startSum = startPointScreen.x + startPointScreen.y;
                const endSum = endPointScreen.x + endPointScreen.y;
                
                if (endSum < startSum) {
                    finalStartPointScreen = endPointScreen;
                    finalEndPointScreen = startPointScreen;
                    switched = true;
                    console.log('Switched start and end points (after coordinate conversion)');
                    console.log('endSum:', endSum.toFixed(2), '< startSum:', startSum.toFixed(2));
                }
                
                console.log('Final stroke start point (screen):', finalStartPointScreen);
                console.log('Final stroke end point (screen):', finalEndPointScreen);
                
                // Calculate direction vector using final converted coordinates (screen coordinate system)
                // Direction: from finalStartPointScreen to finalEndPointScreen
                const dx = finalEndPointScreen.x - finalStartPointScreen.x;
                const dy = finalEndPointScreen.y - finalStartPointScreen.y;
                
                // Calculate angle in radians using atan2
                // Angle is calculated from finalStartPointScreen towards finalEndPointScreen
                // Now using screen coordinates: (0,0) at top-left, y increases downward
                const angle = Math.atan2(dy, dx);
                const angleDegrees = angle * 180 / Math.PI;
                
                console.log('Angle calculated from converted stroke points (screen coordinates)');
                console.log('Direction vector (dx, dy):', dx.toFixed(2), dy.toFixed(2));
                console.log('Angle (degrees):', angleDegrees.toFixed(2));
                
                // Calculate approximate length
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    length += Math.sqrt(
                        Math.pow(curr.x - prev.x, 2) + 
                        Math.pow(curr.y - prev.y, 2)
                    );
                }
                
                return {
                    startPoint: finalStartPoint,
                    endPoint: finalEndPoint,
                    direction: { dx, dy },
                    angle: angle,
                    angleDegrees: angleDegrees,
                    length: length,
                    switched: switched  // Indicate if start/end were switched after coordinate conversion
                };
            }
            
            // Function to process and store stroke data
            function processStrokeData(charData) {
                if (!charData || !charData.strokes) {
                    console.log('No stroke data to process');
                    return;
                }
                
                hanziWriter.strokeData.rawCharData = charData;
                hanziWriter.strokeData.strokes = [];
                hanziWriter.totalStrokes = charData.strokes.length;
                
                // Helper function to parse SVG path
                function parseSVGPath(pathString) {
                    if (!pathString) return null;
                    const commands = pathString.match(/[MLml][\s]*([\d\.\-]+)[\s]*([\d\.\-]+)/g);
                    if (!commands || commands.length === 0) return null;
                    
                    const points = [];
                    for (let cmd of commands) {
                        const coords = cmd.match(/[\d\.\-]+/g);
                        if (coords && coords.length >= 2) {
                            points.push({ 
                                x: parseFloat(coords[0]), 
                                y: parseFloat(coords[1]) 
                            });
                        }
                    }
                    return points.length > 0 ? points : null;
                }
                
                // Process each stroke
                for (let i = 0; i < charData.strokes.length; i++) {
                    const rawStroke = charData.strokes[i];
                    const processedStroke = {
                        index: i,
                        rawData: rawStroke,  // Keep original data for reference
                        
                        // Extracted points
                        points: null,  // All points along the stroke
                        startPoint: null,  // {x, y}
                        endPoint: null,    // {x, y}
                        
                        // Calculated properties
                        direction: null,    // {dx, dy}
                        angle: null,        // angle in radians
                        angleDegrees: null, // angle in degrees
                        length: null,       // approximate stroke length
                        
                        // Metadata
                        source: null  // Which property was used: 'medians', 'path', 'points'
                    };
                    
                    // Try to extract points from different sources
                    let extractedPoints = null;
                    
                    // Try medians first (common in HanziWriter)
                    if (rawStroke.medians && rawStroke.medians.length > 0) {
                        extractedPoints = rawStroke.medians.map(m => ({ x: m[0], y: m[1] }));
                        processedStroke.source = 'medians';
                    } 
                    // Try path (SVG path data)
                    else if (rawStroke.path) {
                        extractedPoints = parseSVGPath(rawStroke.path);
                        processedStroke.source = 'path';
                    }
                    // Try points array
                    else if (rawStroke.points && rawStroke.points.length > 0) {
                        extractedPoints = rawStroke.points.map(p => {
                            if (Array.isArray(p)) {
                                return { x: p[0], y: p[1] };
                            }
                            return p;
                        });
                        processedStroke.source = 'points';
                    }
                    
                    // If we got points, process them
                    if (extractedPoints && extractedPoints.length > 0) {
                        processedStroke.points = extractedPoints;
                        
                        // Calculate stroke angle using the separate function
                        const angleData = calculateStrokeAngle(extractedPoints);
                        if (angleData) {
                            processedStroke.startPoint = angleData.startPoint;
                            processedStroke.endPoint = angleData.endPoint;
                            processedStroke.direction = angleData.direction;
                            processedStroke.angle = angleData.angle;
                            processedStroke.angleDegrees = angleData.angleDegrees;
                            processedStroke.length = angleData.length;
                        }
                    }
                    
                    hanziWriter.strokeData.strokes.push(processedStroke);
                }
                
                hanziWriter.strokeData.initialized = true;
                console.log('Stroke data processed:', hanziWriter.strokeData);
                console.log(`Processed ${hanziWriter.strokeData.strokes.length} strokes`);
            }
            
            // Fallback function for browsers without File System Access API
            function downloadFile(jsonString, fileName = null) {
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = fileName || `stroke_data_${character}_${Date.now()}.json`;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up
                URL.revokeObjectURL(url);
                
                console.log(`File downloaded as: ${link.download}`);
            }
            

            // Button click handlers
            function attachButtonHandler() {
                const btn = document.getElementById('next-stroke-btn');
                if (btn) {
                    // Remove any existing handlers
                    btn.onclick = null;
                    btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('=== BUTTON CLICKED ===');
                        drawNextStroke();
                    });
                    console.log('âœ“ Button click handler attached');
                    return true;
                } else {
                    console.error('âœ— Button not found!');
                    return false;
                }
            }
            
            // Try to attach immediately
            if (!attachButtonHandler()) {
                // If button not found, try again after DOM is ready
                setTimeout(() => {
                    if (attachButtonHandler()) {
                        console.log('Button handler attached on retry');
                    }
                }, 100);
            }
            
        // Load all characters into new structure (in order from ToWriteText.txt)
        function loadAllCharactersIntoStructure() {
            // Clear existing data to prevent duplicates
            if (charactersStrokeDataList.length > 0) {
                console.log('Clearing existing structure data...');
                charactersStrokeDataList = [];
            }
            
            // charactersToLearn is already populated from ToWriteText.txt in order
            console.log(`Loading ${charactersToLearn.length} characters into new structure (in order from ToWriteText.txt)...`);
            
            for (let i = 0; i < charactersToLearn.length; i++) {
                const char = charactersToLearn[i];
                console.log(`Processing character ${i + 1}/${charactersToLearn.length}: ${char}`);
                
                if (!allCharactersData[char]) {
                    console.warn(`Character ${char} not found in allCharactersData`);
                    continue;
                }
                
                const charData = allCharactersData[char];
                
                // Calculate totalStrokes from available sources
                let calculatedTotalStrokes = 0;
                if (charData.totalStrokes && charData.totalStrokes > 0) {
                    calculatedTotalStrokes = charData.totalStrokes;
                } else if (charData.strokes && charData.strokes.length > 0) {
                    calculatedTotalStrokes = charData.strokes.length;
                } else if (charData.rawCharData && charData.rawCharData.strokes && charData.rawCharData.strokes.length > 0) {
                    calculatedTotalStrokes = charData.rawCharData.strokes.length;
                }
                
                // Create structured data entry
                const structuredData = {
                    character: char,
                    unicode: char.charCodeAt(0),
                    unicodeHex: char.charCodeAt(0).toString(16).toUpperCase().padStart(4, '0'),
                    timestamp: new Date().toISOString(),
                    version: '1.0',
                    source: 'all_strokes.json',
                    totalStrokes: calculatedTotalStrokes,
                    strokes: charData.strokes || [],
                    rawCharData: charData.rawCharData || null
                };
                
                // If strokes array is empty but we have rawCharData, we'll process it on demand
                if (structuredData.strokes.length === 0 && structuredData.rawCharData) {
                    console.log(`Character ${char} has no pre-processed strokes, will process from rawCharData when needed`);
                }
                
                if (calculatedTotalStrokes === 0) {
                    console.warn(`Character ${char} has totalStrokes = 0! This may cause issues.`);
                    console.log('charData:', charData);
                }
                
                charactersStrokeDataList.push(structuredData);
                console.log(`Added ${char} to structure list with ${structuredData.totalStrokes} strokes`);
            }
            
            console.log(`Loaded ${charactersStrokeDataList.length} characters into structure list`);
        }
        
        // Load ToWriteText.txt to get characters in order
        async function loadCharactersFromTextFile() {
            try {
                console.log('Fetching ToWriteText.txt...');
                const response = await fetch('ToWriteText.txt');
                if (response.ok) {
                    const text = await response.text();
                    // Extract all characters in order, including duplicates
                    charactersToLearn = Array.from(text).filter(char => {
                        // Keep Chinese characters and other non-whitespace characters
                        return char.trim().length > 0 && char !== '\n' && char !== '\r';
                    });
                    console.log(`Loaded ${charactersToLearn.length} characters from ToWriteText.txt in order`);
                    console.log('First 20 characters:', charactersToLearn.slice(0, 20).join(''));
                    return true;
                } else {
                    console.error(`Failed to load ToWriteText.txt: ${response.status}`);
                    return false;
                }
            } catch (error) {
                console.error('Error loading ToWriteText.txt:', error);
                return false;
            }
        }
        
        // Load all_strokes.json first, then load all characters into new structure
        async function initializeApp() {
            console.log('Initializing app - loading ToWriteText.txt...');
            const textLoaded = await loadCharactersFromTextFile();
            if (!textLoaded) {
                alert('Failed to load ToWriteText.txt. Please make sure the file exists in the same directory.');
                return;
            }
            
            console.log('Initializing app - loading all_strokes.json...');
            const loaded = await loadStrokesDataFromFile();
            if (!loaded) {
                alert('Failed to load all_strokes.json. Please make sure the file exists in the same directory.');
                return;
            }
            
            // Load all characters into new structure (in order from ToWriteText.txt)
            console.log('Loading all characters into new structure...');
            loadAllCharactersIntoStructure();
            
            // Log the loaded structure
            console.log(`Loaded ${charactersStrokeDataList.length} characters into new structure`);
            
            // Set initial character - load from localStorage or start from first
            if (charactersToLearn.length > 0) {
                const startIndex = loadSavedCharacterIndex();
                // Make sure the saved index is valid
                const validIndex = Math.min(startIndex, charactersToLearn.length - 1);
                
                // Load thumbnails for previous characters if resuming
                if (validIndex > 0) {
                    await loadPreviousCharactersThumbnails(validIndex);
                }
                
                // Update main canvas position after loading thumbnails
                setTimeout(() => {
                    updateMainCanvasPosition();
                }, 100);
                
                // Also update on window resize
                window.addEventListener('resize', updateMainCanvasPosition);
                
                character = charactersToLearn[validIndex];
                // Start processing from saved character (or first if none saved)
                processSingleCharacter(validIndex);
            } else {
                alert('No characters found in ToWriteText.txt');
            }
        }
        
        // Stop audio when page is about to unload (refresh/close)
        window.addEventListener('beforeunload', function() {
            if (backgroundMusic) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
            }
        });
        
        // Initialize music control and app when page loads
        function initPage() {
            // Stop any existing audio instances first
            if (backgroundMusic) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
            }
            initMusicControl();
            initializeApp().catch(err => {
                console.error('Error initializing app:', err);
                alert('Error: ' + err.message);
            });
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPage);
        } else {
            initPage();
        }
        
        /**
         * Load character data from the new structure list
         */
        function loadCharacterDataFromStructure(char) {
            // Find character in the structured list
            const structuredCharData = charactersStrokeDataList.find(c => c.character === char);
            
            if (!structuredCharData) {
                console.error(`Character ${char} not found in charactersStrokeDataList`);
                console.error('Available characters in structure:', charactersStrokeDataList.map(c => c.character));
                return false;
            }
            
            console.log(`Loading character data from structure for: ${char}`);
            console.log(`Found structured data: ${structuredCharData.totalStrokes} strokes`);
            
            // Update strokeData with structured data
            hanziWriter.strokeData.character = structuredCharData.character;
            hanziWriter.strokeData.rawCharData = structuredCharData.rawCharData || null;
            
            console.log(`loadCharacterDataFromStructure: rawCharData for ${char}:`, hanziWriter.strokeData.rawCharData ? 'exists' : 'null');
            if (hanziWriter.strokeData.rawCharData) {
                console.log('âœ“ rawCharData loaded successfully');
                console.log('rawCharData keys:', Object.keys(hanziWriter.strokeData.rawCharData));
                if (hanziWriter.strokeData.rawCharData.strokes) {
                    console.log(`âœ“ rawCharData has ${hanziWriter.strokeData.rawCharData.strokes.length} strokes`);
                } else {
                    console.warn('âœ— rawCharData has no strokes array');
                }
            } else {
                console.error('âœ— rawCharData is null! This will cause problems.');
                console.log('structuredCharData.rawCharData:', structuredCharData.rawCharData ? 'exists' : 'null');
            }
            
            // Convert structured strokes to format expected by existing code
            hanziWriter.strokeData.strokes = structuredCharData.strokes.map(stroke => ({
                index: stroke.index,
                rawData: stroke.rawData || null,
                points: stroke.points || null,
                startPoint: stroke.startPoint,
                endPoint: stroke.endPoint,
                direction: stroke.direction,
                angle: stroke.angle,
                angleDegrees: stroke.angleDegrees,
                length: stroke.length,
                source: stroke.source,
                switched: stroke.switched || false
            }));
            
            hanziWriter.totalStrokes = structuredCharData.totalStrokes || (hanziWriter.strokeData.strokes ? hanziWriter.strokeData.strokes.length : 0);
            hanziWriter.strokeData.initialized = true;
            hanziWriter.currentStrokeIndex = 0;
            hanziWriter.drawnStrokes = [];
            
            console.log(`Successfully loaded ${char} from structure with ${hanziWriter.totalStrokes} strokes`);
            console.log(`totalStrokes set to: ${hanziWriter.totalStrokes}`);
            return true;
        }
        
        /**
         * Legacy function - kept for backward compatibility
         * Now uses the new structure list
         */
        function loadCharacterData(char) {
            // Try to load from new structure first
            if (charactersStrokeDataList.length > 0) {
                return loadCharacterDataFromStructure(char);
            }
            
            // Fallback to old method if structure list is empty
            console.log(`Loading character data for: ${char} (fallback to allCharactersData)`);
            console.log(`Available characters:`, Object.keys(allCharactersData));
            
            if (allCharactersData[char]) {
                const charData = allCharactersData[char];
                console.log(`Found data for ${char}:`, charData);
                hanziWriter.strokeData.rawCharData = charData.rawCharData || null;
                
                // If strokes array is empty but we have rawCharData, process it
                if (charData.strokes && charData.strokes.length > 0) {
                    console.log(`Using pre-processed strokes for ${char}:`, charData.strokes.length);
                    hanziWriter.strokeData.strokes = charData.strokes.map(stroke => ({
                        index: stroke.index,
                        rawData: stroke.rawData || null,
                        points: stroke.points || null,
                        startPoint: stroke.startPoint,
                        endPoint: stroke.endPoint,
                        direction: stroke.direction,
                        angle: stroke.angle,
                        angleDegrees: stroke.angleDegrees,
                        length: stroke.length,
                        source: stroke.source
                    }));
                    hanziWriter.totalStrokes = charData.totalStrokes || hanziWriter.strokeData.strokes.length;
                } else if (charData.rawCharData) {
                    // Process rawCharData to extract stroke information
                    console.log(`Processing rawCharData for character: ${char}`);
                    processStrokeData(charData.rawCharData);
                    hanziWriter.totalStrokes = hanziWriter.strokeData.strokes.length;
                    console.log(`Processed ${hanziWriter.totalStrokes} strokes for ${char}`);
                } else {
                    console.error(`No stroke data available for character: ${char}`);
                    console.error('charData:', charData);
                    return false;
                }
                
                hanziWriter.strokeData.initialized = true;
                hanziWriter.currentStrokeIndex = 0;
                hanziWriter.drawnStrokes = [];
                hanziWriter.isAnimating = false;
                console.log(`Successfully loaded ${char} with ${hanziWriter.totalStrokes} strokes`);
                return true;
            } else {
                console.error(`Character ${char} not found in allCharactersData`);
                console.error('Available characters:', Object.keys(allCharactersData));
                return false;
            }
        }
        
        async function loadStrokesDataFromFile() {
            // Load stroke data from all_strokes.json file
            try {
                console.log('Fetching all_strokes.json...');
                const response = await fetch('all_strokes.json');
                console.log('Response status:', response.status, response.statusText);
                
                if (response.ok) {
                    const loadedData = await response.json();
                    console.log('Parsed JSON data. Keys:', Object.keys(loadedData));
                    
                    if (loadedData.characters && typeof loadedData.characters === 'object') {
                        allCharactersData = loadedData.characters;
                        const charCount = Object.keys(allCharactersData).length;
                        console.log(`Successfully loaded ${charCount} characters from all_strokes.json`);
                        console.log('First few characters:', Object.keys(allCharactersData).slice(0, 10));
                        return true;
                    } else {
                        console.error('Invalid data format. Expected "characters" object.');
                        console.error('Data structure:', Object.keys(loadedData));
                    }
                } else {
                    console.error(`HTTP error: ${response.status} ${response.statusText}`);
                }
                return false;
            } catch (error) {
                console.error('Error loading all_strokes.json:', error);
                console.error('Error details:', error.message, error.stack);
                return false;
            }
        }
        
        function processSingleCharacter(charIndex) {
            // Process a single character using the new structure list
            if (charIndex >= charactersToLearn.length) {
                // All characters completed
                console.log(`All ${charactersToLearn.length} characters completed!`);
                alert(`Congratulations! You have completed all ${charactersToLearn.length} characters!`);
                return;
            }
            
            character = charactersToLearn[charIndex];
            currentCharacterIndex = charIndex;
            // Save current character index to localStorage
            saveCharacterIndex(charIndex);
            
            console.log(`Processing character ${charIndex + 1}/${charactersToLearn.length}: ${character}`);
            
            // Check if structure list is loaded
            if (charactersStrokeDataList.length === 0) {
                console.error('charactersStrokeDataList is empty. Make sure initializeApp() has loaded the data.');
                alert('Character data not loaded. Please refresh the page.');
                return;
            }
            
            // Load stroke data from the new structure list
            console.log(`Loading stroke data for character: ${character}`);
            console.log(`charactersStrokeDataList has ${charactersStrokeDataList.length} characters`);
            
            if (!loadCharacterDataFromStructure(character)) {
                console.error(`Failed to load stroke data for: ${character} from structure list`);
                console.error('Available characters in structure:', charactersStrokeDataList.map(c => c.character));
                alert(`Stroke data not found for character: ${character}\n\nAvailable: ${charactersStrokeDataList.map(c => c.character).join(', ')}`);
                return;
            }
            
            console.log(`âœ“ Character data loaded. strokeData.rawCharData:`, hanziWriter.strokeData.rawCharData ? 'exists' : 'null');
            if (hanziWriter.strokeData.rawCharData) {
                console.log(`âœ“ rawCharData has ${hanziWriter.strokeData.rawCharData.strokes ? hanziWriter.strokeData.rawCharData.strokes.length : 0} strokes`);
            }
            
            console.log(`Loaded stroke data for ${character} from structure (${hanziWriter.totalStrokes} strokes)`);
            
            // Log structure information
            const structuredData = charactersStrokeDataList.find(c => c.character === character);
            if (structuredData) {
                console.log(`Character structure:`, {
                    character: structuredData.character,
                    unicodeHex: structuredData.unicodeHex,
                    totalStrokes: structuredData.totalStrokes,
                    version: structuredData.version,
                    source: structuredData.source
                });
            }
            
            // Reset stroke tracking (start at 0, no strokes drawn yet)
            hanziWriter.currentStrokeIndex = 0;
            hanziWriter.drawnStrokes = [];
            hanziWriter.isAnimating = false;
            hanziWriter.guideDrawn = false; // Reset guide flag for new character
            // DON'T reset totalStrokes - it should already be set from loadCharacterDataFromStructure
            console.log(`processSingleCharacter: totalStrokes = ${hanziWriter.totalStrokes}, character = ${character}`);
            
            // If totalStrokes is still 0, try to get it from structure
            if (hanziWriter.totalStrokes === 0) {
                const charData = charactersStrokeDataList.find(c => c.character === character);
                if (charData && charData.rawCharData && charData.rawCharData.medians) {
                    hanziWriter.totalStrokes = charData.rawCharData.medians.length;
                    console.log(`Set totalStrokes to ${hanziWriter.totalStrokes} from medians in processSingleCharacter`);
                } else if (charData) {
                    hanziWriter.totalStrokes = charData.totalStrokes || (charData.strokes ? charData.strokes.length : 0);
                    console.log(`Set totalStrokes to ${hanziWriter.totalStrokes} from structure in processSingleCharacter`);
                }
            }
            
            // Initialize canvas (character is shown, ready for drag/touch)
            setTimeout(() => {
                hanziWriter.initCanvas();
                // Wait a bit to ensure canvas is fully initialized and guide is drawn
                setTimeout(() => {
                    updateProgressDisplay();
                    console.log(`Character ${character} displayed. Drag or touch anywhere to draw strokes...`);
                }, 50);
            }, 100);
        }
        
        function onCharacterCompleted() {
            // Prevent duplicate calls
            if (isCompletingCharacter) {
                console.log('Character completion already in progress, skipping duplicate call');
                return;
            }
            isCompletingCharacter = true;
            
            // Called when all strokes of current character are completed
            console.log(`Character ${character} completed! Moving to next character...`);
            
            // Capture the completed character and add it to the top right corner
            if (hanziWriter.canvas && hanziWriter.ctx) {
                const characterWrapper = document.querySelector('.character-wrapper');
                const container = document.getElementById('completed-characters-container');
                
                if (!characterWrapper || !container) return;
                
                // Step 1: Add explosive shining animation to the canvas
                characterWrapper.classList.add('shining');
                
                // Step 2: Capture the canvas after shine animation
                setTimeout(() => {
                    // Create a temporary canvas to capture the current state
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = hanziWriter.canvas.width;
                    tempCanvas.height = hanziWriter.canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw the current canvas content to the temp canvas
                    tempCtx.drawImage(hanziWriter.canvas, 0, 0);
                    
                    // Create a new canvas for the 36x36 thumbnail
                    const thumbnailCanvas = document.createElement('canvas');
                    thumbnailCanvas.width = 36;
                    thumbnailCanvas.height = 36;
                    const thumbnailCtx = thumbnailCanvas.getContext('2d');
                    
                    // Draw the temp canvas scaled down to 36x36
                    thumbnailCtx.drawImage(tempCanvas, 0, 0, 36, 36);
                    
                    // Convert to image data URL
                    const imageDataUrl = thumbnailCanvas.toDataURL('image/png');
                    
                    // Get positions for animation
                    const wrapperRect = characterWrapper.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    // Calculate target position (top-right of container, accounting for new item)
                    const targetX = containerRect.right - 46; // 36px + 10px padding
                    const targetY = containerRect.top + 10 + (container.children.length % 20) * 36;
                    
                    // Step 3: Create flying thumbnail
                    const flyingImg = document.createElement('img');
                    flyingImg.src = imageDataUrl;
                    flyingImg.className = 'flying-thumbnail';
                    flyingImg.style.width = `${wrapperRect.width}px`;
                    flyingImg.style.height = `${wrapperRect.height}px`;
                    flyingImg.style.left = `${wrapperRect.left + wrapperRect.width / 2}px`;
                    flyingImg.style.top = `${wrapperRect.top + wrapperRect.height / 2}px`;
                    flyingImg.style.transform = 'translate(-50%, -50%)';
                    document.body.appendChild(flyingImg);
                    
                    // Remove shine class
                    characterWrapper.classList.remove('shining');
                    
                    // Start loading next character immediately (before flying animation starts)
                    const nextIndex = currentCharacterIndex + 1;
                    if (nextIndex < charactersToLearn.length) {
                        // Start loading next character right away so guide animation begins before flying
                        isCompletingCharacter = false; // Reset flag before processing next character
                        processSingleCharacter(nextIndex);
                    }
                    
                    // Step 4: Animate flying thumbnail to container (starts after next character begins loading)
                    setTimeout(() => {
                        flyingImg.style.left = `${targetX}px`;
                        flyingImg.style.top = `${targetY}px`;
                        flyingImg.style.width = '36px';
                        flyingImg.style.height = '36px';
                        flyingImg.style.transform = 'translate(-50%, -50%) scale(0.8)';
                        flyingImg.style.opacity = '0.9';
                    }, 10);
                    
                    // Step 5: After animation completes, add final thumbnail and remove flying one
                    setTimeout(() => {
                        // Play completion sound effect
                        const completionSound = document.getElementById('completion-sound');
                        if (completionSound && completionSound.src) {
                            // If audio file is available, use it
                            completionSound.currentTime = 0;
                            completionSound.play().catch(e => {
                                console.log('Could not play completion sound:', e);
                            });
                        } else {
                            // Fallback: Create a simple beep sound using Web Audio API
                            try {
                                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                                const oscillator = audioContext.createOscillator();
                                const gainNode = audioContext.createGain();
                                
                                oscillator.connect(gainNode);
                                gainNode.connect(audioContext.destination);
                                
                                oscillator.frequency.value = 800; // Higher pitch
                                oscillator.type = 'sine';
                                
                                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                                
                                oscillator.start(audioContext.currentTime);
                                oscillator.stop(audioContext.currentTime + 0.15);
                            } catch (e) {
                                console.log('Could not play completion sound:', e);
                            }
                        }
                        
                        // Create final thumbnail element
                        const img = document.createElement('img');
                        img.src = imageDataUrl;
                        img.alt = character;
                        
                        const completedDiv = document.createElement('div');
                        completedDiv.className = 'completed-character';
                        completedDiv.appendChild(img);
                        
                        container.appendChild(completedDiv);
                        
                        // Container height is automatically managed by top/bottom positioning
                        container.style.overflow = 'hidden';
                        
                        // Remove flying thumbnail
                        flyingImg.remove();
                        
                        // Update main canvas position based on container width
                        updateMainCanvasPosition();
                    }, 700); // Wait for animation to complete
                    
                    // Handle case when all characters are completed
                    if (nextIndex >= charactersToLearn.length) {
                        setTimeout(() => {
                            console.log('All characters completed!');
                            isCompletingCharacter = false; // Reset flag
                            // Reset to first character when all are completed
                            saveCharacterIndex(0);
                        }, 700); // After flying animation completes
                    }
                }, 800); // Wait for shine animation to complete
            } else {
                // If canvas not available, just move to next character immediately
                const nextIndex = currentCharacterIndex + 1;
                if (nextIndex < charactersToLearn.length) {
                    isCompletingCharacter = false;
                    processSingleCharacter(nextIndex);
                } else {
                    isCompletingCharacter = false;
                    saveCharacterIndex(0);
                }
            }
        }
        
        function moveToNextCharacter() {
            // Legacy function - now uses processSingleCharacter
            onCharacterCompleted();
        }
        
        function updateProgressDisplay() {
            const infoDisplay = document.getElementById('next-stroke-btn');
            if (infoDisplay) {
                const currentChar = charactersToLearn[currentCharacterIndex] || '';
                infoDisplay.textContent = `èˆ¬è‹¥æ³¢ç½—èœœå¿ƒç» ${currentCharacterIndex + 1}/${charactersToLearn.length} (${currentChar})`;
            }
        }
        
        // Update main canvas position based on container width
        function updateMainCanvasPosition() {
            const wrapper = document.getElementById('canvas-container-wrapper');
            const container = document.getElementById('completed-characters-container');
            const characterWrapper = document.querySelector('.character-wrapper');
            const mainContent = document.querySelector('.main-content');
            
            if (wrapper && container && characterWrapper && mainContent) {
                // Update container width first to ensure it's based on content
                updateContainerWidth();
                
                // Get container width (including padding) after updating
                const containerWidth = container.offsetWidth;
                // Get canvas width
                const canvasWidth = characterWrapper.offsetWidth || 800;
                // Get available viewport width
                const viewportWidth = window.innerWidth;
                // Calculate minimum space needed (canvas + container + gaps + margins)
                const minSpaceNeeded = canvasWidth + containerWidth + 60; // 60px for gaps and margins
                
                // Check if we need vertical layout
                if (viewportWidth < minSpaceNeeded) {
                    // Not enough horizontal space - use vertical layout
                    wrapper.classList.remove('horizontal-layout');
                    wrapper.classList.add('vertical-layout');
                    mainContent.style.marginRight = '0';
                } else {
                    // Enough space - use horizontal layout
                    wrapper.classList.remove('vertical-layout');
                    wrapper.classList.add('horizontal-layout');
                    // Ensure container width is recalculated for horizontal layout
                    updateContainerWidth();
                    // Add right margin to reserve space for container, keeping canvas centered in remaining space
                    const totalOffset = containerWidth + 20;
                    mainContent.style.marginRight = `${totalOffset}px`;
                }
            }
        }
        
        async function drawNextStroke() {
            console.log('=== drawNextStroke called ===');
            console.log('canvas:', !!hanziWriter.canvas);
            console.log('ctx:', !!hanziWriter.ctx);
            console.log('currentStrokeIndex:', hanziWriter.currentStrokeIndex);
            console.log('totalStrokes:', hanziWriter.totalStrokes);
            console.log('isAnimating:', hanziWriter.isAnimating);
            
            if (!hanziWriter.canvas || !hanziWriter.ctx) {
                console.error('Canvas not initialized');
                alert('Canvas not initialized. Please refresh the page.');
                return;
            }
            
            // Get total strokes from our loaded structure
            if (hanziWriter.totalStrokes === 0) {
                console.log('totalStrokes is 0, trying to get from structure...');
                console.log('current character:', character);
                
                // First, try to reload from structure if not initialized
                if (!hanziWriter.strokeData.initialized || !hanziWriter.strokeData.rawCharData) {
                    console.log('strokeData not initialized, reloading from structure...');
                    if (!loadCharacterDataFromStructure(character)) {
                        console.error(`Failed to reload character data for: ${character}`);
                        alert(`Failed to load stroke data for ${character}`);
                        return;
                    }
                }
                
                // Try to get from medians
                if (hanziWriter.strokeData.rawCharData && hanziWriter.strokeData.rawCharData.medians) {
                    hanziWriter.totalStrokes = hanziWriter.strokeData.rawCharData.medians.length;
                    console.log(`âœ“ Found ${hanziWriter.totalStrokes} strokes from medians`);
                } else {
                    // Try to get from structure
                    const charData = charactersStrokeDataList.find(c => c.character === character);
                    if (charData && charData.rawCharData && charData.rawCharData.medians) {
                        hanziWriter.totalStrokes = charData.rawCharData.medians.length;
                        console.log(`âœ“ Found ${hanziWriter.totalStrokes} strokes from structure medians`);
                    } else if (charData) {
                        hanziWriter.totalStrokes = charData.totalStrokes || 0;
                        console.log(`âœ“ Found ${hanziWriter.totalStrokes} strokes from structure totalStrokes`);
                    }
                }
                
                // Final check
                if (hanziWriter.totalStrokes === 0) {
                    console.error('No stroke data available');
                    alert(`No stroke data available for ${character}`);
                    return;
                }
            }
            
            // Check if all strokes are done (but only if not already completing)
            if (hanziWriter.currentStrokeIndex >= hanziWriter.totalStrokes && !isCompletingCharacter) {
                console.log('All strokes done, moving to next character');
                onCharacterCompleted();
                return;
            }
            
            if (hanziWriter.isAnimating) {
                console.log('Already animating, ignoring click');
                return;
            }
            
            const infoDisplay = document.getElementById('next-stroke-btn');
            const strokeNum = hanziWriter.currentStrokeIndex;
            
            console.log(`=== About to draw stroke ${strokeNum + 1}/${hanziWriter.totalStrokes} ===`);
            
            // Set isAnimating flag early to prevent race conditions
            // It will be set again in drawStroke, but this ensures immediate protection
            hanziWriter.isAnimating = true;
            
            if (infoDisplay) {
                const currentChar = charactersToLearn[currentCharacterIndex] || '';
                infoDisplay.textContent = `èˆ¬è‹¥æ³¢ç½—èœœå¿ƒç» ${currentCharacterIndex + 1}/${charactersToLearn.length} (${currentChar})`;
            }
            
            try {
                // If this is the first stroke, ensure guide character is drawn first
                if (strokeNum === 0 && hanziWriter.drawnStrokes.length === 0) {
                    // Ensure guide character is drawn on guide canvas before first stroke
                    if (hanziWriter.guideCtx && hanziWriter.strokeData.rawCharData && hanziWriter.strokeData.rawCharData.medians) {
                        hanziWriter.drawGuideCharacter();
                        // Reset stroke style
                        hanziWriter.ctx.strokeStyle = '#1C1C1C'; // Drawing color
                        hanziWriter.ctx.lineWidth = 25;
                        // Small delay to ensure guide is rendered
                        await new Promise(resolve => setTimeout(resolve, 30));
                        // Set currentStrokeIndex to zero after guide is prepared
                        hanziWriter.currentStrokeIndex = 0;
                    }
                }
                
                // Draw the stroke
                hanziWriter.drawStroke(strokeNum, true); // true = animate
                
                // Mark stroke as drawn
                if (!hanziWriter.drawnStrokes.includes(strokeNum)) {
                    hanziWriter.drawnStrokes.push(strokeNum);
                }
                
                // Wait for animation to complete (check every 50ms)
                let checkCount = 0;
                const maxChecks = 200; // Maximum 10 seconds (200 * 50ms)
                function checkAnimationComplete() {
                    checkCount++;
                    if (checkCount > maxChecks) {
                        console.error('Animation check timeout - forcing completion');
                        hanziWriter.isAnimating = false;
                        // Mark stroke as drawn now that animation is complete
                        if (!hanziWriter.drawnStrokes.includes(strokeNum)) {
                            hanziWriter.drawnStrokes.push(strokeNum);
                        }
                        hanziWriter.currentStrokeIndex++;
                        updateProgressDisplay();
                        if (hanziWriter.currentStrokeIndex >= hanziWriter.totalStrokes) {
                            setTimeout(() => {
                                onCharacterCompleted();
                            }, 500);
                        }
                        return;
                    }
                    
                    if (!hanziWriter.isAnimating) {
                        // Animation completed - NOW increment the index
                        hanziWriter.currentStrokeIndex++;
                        
                        updateProgressDisplay();
                        
                        if (hanziWriter.currentStrokeIndex >= hanziWriter.totalStrokes) {
                            console.log('All strokes completed for this character');
                            setTimeout(() => {
                                onCharacterCompleted();
                            }, 500);
                        }
                    } else {
                        // Still animating, check again
                        setTimeout(checkAnimationComplete, 50);
                    }
                }
                
                // Start checking after a short delay
                setTimeout(checkAnimationComplete, 100);
                
            } catch (e) {
                console.error('Error drawing stroke:', e);
                hanziWriter.isAnimating = false;
                updateProgressDisplay();
                alert('Error drawing stroke: ' + e.message);
            }
        }

        // Function to calculate angle of user movement
        function checkStrokeSimilarity(userPath, strokeIndex) {
            let result = {
                userAngle: null,
                strokeAngle: null,
                similarity: 0.5
            };
            
            if (!userPath || userPath.length < 2) {
                console.log('User path too short:', userPath ? userPath.length : 'null');
                return result;
            }
            
            // Get user movement start and end points from screen coordinates
            // Screen coordinates: (0,0) at top-left, y increases downward
            const userStart = userPath[0];
            const userEnd = userPath[userPath.length - 1];
            
            console.log('User path start:', userStart, 'User path end:', userEnd);
            console.log('User path length:', userPath.length);
            
            // Calculate direction vector (angle) - using screen coordinates
            const userDx = userEnd.x - userStart.x;
            const userDy = userEnd.y - userStart.y;
            
            console.log('User dx:', userDx, 'User dy:', userDy);
            
            // Calculate angle in radians using atan2
            // User coordinates: (0,0) at top-left, y increases downward
            result.userAngle = Math.atan2(userDy, userDx);
            
            console.log('User angle (radians):', result.userAngle);
            console.log('User angle (degrees):', result.userAngle * 180 / Math.PI);
            
            // Get stroke angle from stored stroke data
            if (hanziWriter.strokeData.initialized && hanziWriter.strokeData.strokes[strokeIndex]) {
                const storedStroke = hanziWriter.strokeData.strokes[strokeIndex];
                result.strokeAngle = storedStroke.angle;
                console.log('Stroke angle from stored data:', storedStroke.angle);
                console.log('Stroke angle (degrees):', storedStroke.angleDegrees);
            } else {
                console.log('Stroke data not initialized or stroke not found:', {
                    initialized: hanziWriter.strokeData.initialized,
                    strokeIndex: strokeIndex,
                    strokesLength: hanziWriter.strokeData.strokes ? hanziWriter.strokeData.strokes.length : 0
                });
            }
            
            return result;
        }


        // Add drag/touch detection anywhere on the page - any drag/touch draws next stroke
        function initDragDetection() {
            let isDragging = false;
            let hasTriggered = false; // Prevent multiple triggers from same drag
            let startX = 0;
            let startY = 0;
            const MIN_DRAG_DISTANCE = 30; // Minimum distance in pixels to trigger stroke drawing

            function getEventCoordinates(e) {
                // Handle both mouse and touch events
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                } else {
                    return { x: e.clientX, y: e.clientY };
                }
            }

            function handleStart(e) {
                // Don't trigger on button clicks or music toggle
                if (e.target && (
                    e.target.id === 'next-stroke-btn' || 
                    e.target.closest('#next-stroke-btn') ||
                    e.target.id === 'music-toggle' ||
                    e.target.closest('#music-toggle') ||
                    e.target.closest('.music-control')
                )) {
                    return;
                }
                // Prevent text selection during drag
                e.preventDefault();
                const coords = getEventCoordinates(e);
                startX = coords.x;
                startY = coords.y;
                isDragging = true;
                hasTriggered = false;
            }

            function handleMove(e) {
                if (!isDragging) return;
                e.preventDefault();
            }

            async function handleEnd(e) {
                // Don't trigger on button clicks or music toggle
                if (e.target && (
                    e.target.id === 'next-stroke-btn' || 
                    e.target.closest('#next-stroke-btn') ||
                    e.target.id === 'music-toggle' ||
                    e.target.closest('#music-toggle') ||
                    e.target.closest('.music-control')
                )) {
                    isDragging = false;
                    return;
                }
                
                if (!isDragging || hasTriggered) {
                    isDragging = false;
                    hasTriggered = false;
                    return;
                }
                
                // Get end coordinates
                const coords = getEventCoordinates(e);
                const endX = coords.x;
                const endY = coords.y;
                
                // Calculate drag distance
                const dragDistance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                
                // Only proceed if drag distance is greater than minimum threshold
                if (dragDistance < MIN_DRAG_DISTANCE) {
                    console.log(`[handleEnd] Drag distance too short: ${dragDistance.toFixed(2)}px (minimum: ${MIN_DRAG_DISTANCE}px), ignoring`);
                    isDragging = false;
                    hasTriggered = false;
                    return;
                }
                
                // Check if we can draw
                if (hanziWriter.isAnimating) {
                    console.log(`[handleEnd] Animation in progress, ignoring drag`);
                    isDragging = false;
                    hasTriggered = false;
                    return;
                }
                
                if (!hanziWriter.canvas || !hanziWriter.ctx) {
                    isDragging = false;
                    hasTriggered = false;
                    return;
                }
                
                // Drag distance is sufficient, draw the next stroke
                hasTriggered = true;
                console.log(`[handleEnd] Drag/touch detected (distance: ${dragDistance.toFixed(2)}px) - drawing next stroke`);
                
                // Call drawNextStroke to draw the next stroke (it's async)
                await drawNextStroke();
                
                isDragging = false;
                e.preventDefault();
            }

            // Mouse events
            document.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('mouseleave', handleEnd);

            // Touch events
            document.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('touchend', handleEnd, { passive: false });
            document.addEventListener('touchcancel', handleEnd, { passive: false });
        }

        // Start when page loads - only initialize drag detection
        // initializeApp() already handles canvas initialization
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                initDragDetection();
            });
        } else {
            initDragDetection();
        }
    </script>
</body>
</html>
